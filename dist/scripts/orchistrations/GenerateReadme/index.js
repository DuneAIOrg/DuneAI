"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EditDynamic = exports.SectionDynamic = exports.StructureDynamic = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
// @ts-ignore
const duneai_1 = require("duneai");
const fullPath = path_1.default.resolve(__dirname, "./prompts.prompt");
const { Structure, Section, Edit } = (0, duneai_1.importPrompts)(fullPath);
const StructureDynamic = (context) => (0, duneai_1.createDynamic)({
    name: 'Structure',
    kind: duneai_1.COT,
    context,
    prompts: [{ Structure }]
});
exports.StructureDynamic = StructureDynamic;
const SectionDynamic = (context) => (0, duneai_1.createDynamic)({
    name: 'SectionDynamic',
    kind: duneai_1.COT,
    context,
    prompts: [{ [context.currentSection.trim()]: Section }]
});
exports.SectionDynamic = SectionDynamic;
const EditDynamic = (context) => (0, duneai_1.createDynamic)({
    name: 'EditDynamic',
    kind: duneai_1.COT,
    context,
    prompts: [{ Edit }]
});
exports.EditDynamic = EditDynamic;
const introduction = `
DuneAI: The World's First Open Source Cybernetic Orchestration Framework

DuneAI is a breakthrough in artificial intelligence orchestration, built on the principles of cybernetics. As the world’s first open-source Cybernetic Orchestration Framework, DuneAI offers a new level of intelligence, flexibility, and adaptability to AI workflows. Unlike conventional systems, DuneAI enables AI to analyze its own outputs and adjust future actions, resulting in self-evolving, adaptive systems.

What makes DuneAI unique is its ability to form cybernetic feedback loops—allowing AI to continuously refine its behavior based on its outputs. While traditional frameworks focus on chaining operations or retrieving data, DuneAI empowers AI to learn from its results and modify its decision-making process autonomously. This makes DuneAI particularly effective for complex workflows that require ongoing adaptation.
The Core of DuneAI

DuneAI’s functionality is built around two core constructs: Dynamics and Prompts.

    Dynamics are reusable, state-aware components that manage how workflows are executed. They adapt based on the AI's evolving state, allowing for flexible orchestration.

    Prompts are modular commands that interface with AI models. Enhanced with Mustache syntax, Prompts allow dynamic state injection at runtime, ensuring interactions evolve as workflows progress. Prompts not only retrieve outputs but also shape the workflow in response to real-time state changes.

These constructs work together to enable adaptive orchestration, where workflows adjust and refine themselves through cybernetic feedback.
A New Approach to AI Orchestration

DuneAI offers a fresh approach to AI orchestration, focusing on self-refining workflows that evolve through continuous feedback. This adaptive capability goes beyond what is offered by traditional frameworks, providing more intelligent, autonomous systems for handling dynamic tasks.

DuneAI is licensed under the MIT license and was created by Kenan Stipek with the support of the team at AllusionLabs. This README was written by Kenan Stipek and generated by DuneAI itself, using OpenAI’s GPT-4o-mini model to process DuneAI’s own source code.
`;
const generateReadme = () => __awaiter(void 0, void 0, void 0, function* () {
    const sourceDir = path_1.default.resolve(__dirname, '../..');
    const readmePath = path_1.default.join(sourceDir, 'README.md');
    // Function to read the source code files
    const readSourceFiles = (dir) => {
        let results = [];
        const gitignorePath = path_1.default.resolve(__dirname, '../../../.gitignore');
        const gitignorePatterns = fs_1.default.readFileSync(gitignorePath, 'utf8')
            .split('\n')
            .filter((line) => line && !line.startsWith('#'))
            .map((pattern) => new RegExp(pattern.replace(/\*/g, '.*')));
        const isIgnored = (file) => {
            return gitignorePatterns.some((pattern) => pattern.test(file));
        };
        const list = fs_1.default.readdirSync(dir);
        list.forEach((file) => {
            file = path_1.default.join(dir, file);
            if (isIgnored(file)) {
                return;
            }
            const stat = fs_1.default.statSync(file);
            if (stat && stat.isDirectory()) {
                results = results.concat(readSourceFiles(file));
            }
            else if (file.endsWith('.ts') || file.endsWith('.js')) {
                results.push(file);
            }
        });
        return results;
    };
    // Function to extract relevant information from the source code
    const extractInfoFromSource = (files) => __awaiter(void 0, void 0, void 0, function* () {
        let info = '';
        files.forEach((file) => {
            const content = fs_1.default.readFileSync(file, 'utf8');
            info += `\n\n### ${file}\n\`\`\`typescript\n${content}\n\`\`\`\n`;
        });
        return info;
    });
    // Read all source files
    const sourceFiles = readSourceFiles(sourceDir);
    // Extract information from the source files
    const extractedInfo = yield extractInfoFromSource(sourceFiles);
    const structure = yield (0, exports.StructureDynamic)({ extractedInfo, introduction }).run({});
    let allSections = '';
    // @ts-ignore
    for (const rawCurrentSection of structure.Structure.Structure.split(',')) {
        const currentSection = rawCurrentSection.trim();
        const sectionContent = yield (0, exports.SectionDynamic)({ extractedInfo, structure, currentSection, allSections, introduction }).run({});
        // @ts-ignore
        allSections += sectionContent.SectionDynamic[currentSection];
    }
    const edit = yield (0, exports.EditDynamic)({ allSections: `${introduction}\n\n${allSections}` }).run({});
    // @ts-ignore
    const finalCopy = edit.EditDynamic.Edit;
    // Write the extracted information to the README.md file
    fs_1.default.writeFileSync(readmePath, finalCopy);
});
// Run the generateReadme function
generateReadme().then(() => {
    console.log('README.md has been generated successfully.');
}).catch((error) => {
    console.error('Error generating README.md:', error);
});
