{
  "state": {},
  "context": {
    "extractedInfo": "\n\n### Y:\\allusion\\DuneAI\\src\\adapter\\index.ts\n```typescript\nimport Providers from './providers'\r\nimport { throttle } from './throttle'\r\n\r\nconst DEFAULT_ADAPTER = process.env.DEFAULT_ADAPTER || 'openai';\r\nconst DEFAULT_MODEL = process.env.DEFAULT_MODEL || 'gpt-4o-mini';\r\n\r\n// Unified ask method that delegates to the correct adapter based on the modelKey.\r\n// Also applies throttle that reflects env variable settings.\r\nexport const ask = async (\r\n  prompt: string | Record<string, any>,\r\n  adapterName: string = DEFAULT_ADAPTER,\r\n  modelName: string = DEFAULT_MODEL,\r\n  options?: any\r\n) => {\r\n  console.log('getCompletion:prompt', prompt)\r\n  console.log('getCompletion:options', options)\r\n\r\n  const adapter = Providers[adapterName as keyof typeof Providers];\r\n  if (typeof adapter !== 'function') {\r\n    throw new TypeError(`Adapter ${adapterName} is not valid, here are the available adapters: ${Object.keys(Providers).join(', ')}`);\r\n  }\r\n  const randomId = Math.floor(Math.random() * 1000000);\r\n  return await throttle(\r\n    () => adapter(prompt, { model: modelName, ...options }),\r\n    { id: `ask_operation_${randomId}` }\r\n  );\r\n};\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\adapter\\providers\\gpt4all.ts\n```typescript\nimport \"dotenv/config\";\r\nimport { ChatSession, CompletionResult, createCompletion } from \"gpt4all\";\r\n\r\nexport type GetCompletionOptions = {\r\n    model: string;\r\n    host?: string;\r\n    protocol?: 'http' | 'https';\r\n    port?: number;\r\n    max_tokens?: number;\r\n    temperature?: number;\r\n} | {\r\n  session: ChatSession\r\n}\r\n\r\nconst getBaseUrl = (options?: GetCompletionOptions) => {\r\n  if (options && 'session' in options) {\r\n    return\r\n  }\r\n\r\n   const url = new URL('http://localhost:4891');\r\n   if (options?.host) {\r\n     url.host = options.host;\r\n   }\r\n\r\n    if (options?.protocol) {\r\n      url.protocol = options.protocol;\r\n    }\r\n\r\n    if (options?.port) {\r\n      url.port = options.port.toString();\r\n    }\r\n\r\n    return url.toString();\r\n}\r\n\r\nconst getCompletion = async (content: string, options?: GetCompletionOptions) => {\r\n  const isSession = options && 'session' in options\r\n\r\n  const params = {\r\n    max_tokens: isSession ? 512 : options?.max_tokens ?? 512,\r\n    temperature: isSession ? 0.24 : options?.temperature ?? 0.24,\r\n    ...options,\r\n  };\r\n\r\n  // @ts-expect-error\r\n  const { adapter: _, ...gpt4allParams } = params;\r\n\r\n  const apiBaseUrl = getBaseUrl(options);\r\n\r\n  let completion: CompletionResult\r\n\r\n  if (isSession) {\r\n    completion = await createCompletion(options.session, content, {\r\n      tokensSize: gpt4allParams.max_tokens,\r\n      temperature: gpt4allParams.temperature,\r\n    })\r\n  } else {\r\n    const response = await fetch(apiBaseUrl + 'v1/chat/completions', {\r\n      method: 'POST',\r\n      body: JSON.stringify(gpt4allParams),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`GTP4All API error: ${response.statusText}`);\r\n    }\r\n\r\n    completion = await response.json();\r\n  }\r\n\r\n  return {\r\n    content: completion?.choices?.[0]?.message?.content ?? '',\r\n    meta: completion\r\n  };\r\n};\r\n\r\nexport const ask = async (\r\n  prompt: string | Record<string, any>,\r\n  options?: GetCompletionOptions,\r\n) => {\r\n  const result = await getCompletion(prompt as string, options);\r\n  return { content: result.content, meta: result.meta };\r\n};\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\adapter\\providers\\index.ts\n```typescript\nimport { ask as openai } from \"./openai\";\r\nimport { ask as gpt4all } from \"./gpt4all\";\r\n\r\nexport default { openai, gpt4all }\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\adapter\\providers\\openai.ts\n```typescript\nimport \"dotenv/config\";\r\n\r\nconst OPENAI_API_KEY = process.env.OPENAI_API_KEY || 'openai_api_key';\r\nconst DEFAULT_MODEL = process.env.DEFAULT_MODEL || 'gpt-4o-mini';\r\n\r\nconst getCompletion = async (content: string, options: { model?: string }) => {\r\n  const params = {\r\n    messages: [{ role: \"user\", content }],\r\n    model: options.model || DEFAULT_MODEL,\r\n    ...options,\r\n  };\r\n  // @ts-ignore\r\n  const { adapter: _, ...openaiParams } = params;\r\n\r\n  const response = await fetch('https://api.openai.com/v1/chat/completions', {\r\n    method: 'POST',\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      'Authorization': `Bearer ${OPENAI_API_KEY}`,\r\n    },\r\n    body: JSON.stringify(openaiParams),\r\n  });\r\n\r\n  if (!response.ok) {\r\n    throw new Error(`OpenAI API error: ${response.statusText}`);\r\n  }\r\n\r\n  const chatCompletion = await response.json();\r\n  return {\r\n    content: chatCompletion.choices[0].message?.content,\r\n    meta: chatCompletion\r\n  };\r\n};\r\n\r\nexport const ask = async (\r\n  prompt: string | Record<string, any>,\r\n  options?: any,\r\n) => {\r\n  const result = await getCompletion(prompt as string, options);\r\n  return { content: result.content, meta: result.meta };\r\n};\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\adapter\\throttle.ts\n```typescript\nimport { retryOperation } from \"../utils\";\r\nimport \"dotenv/config\";\r\n\r\nexport const DELAY = parseInt(process.env.DELAY || '500', 10);\r\nexport const RETRY_COUNT = parseInt(process.env.RETRY_COUNT || '3', 10);\r\nexport const MAX_RPM = parseInt(process.env.MAX_RPM || '10000', 10);\r\nexport const MAX_CONCURRENT = parseInt(process.env.MAX_CONCURRENT || MAX_RPM.toString(), 10);\r\n\r\nlet currentConcurrent = 0;\r\nconst queue: { operation: () => Promise<any>; resolve: (value: any) => void; reject: (reason?: any) => void; }[] = [];\r\n\r\nconst processQueue = async () => {\r\n  if (queue.length === 0 || currentConcurrent >= MAX_CONCURRENT) {\r\n    return;\r\n  }\r\n\r\n  const { operation, resolve, reject } = queue.shift()!;\r\n  currentConcurrent++;\r\n\r\n  try {\r\n    const result = await retryOperation(operation, DELAY, RETRY_COUNT);\r\n    resolve(result);\r\n  } catch (error) {\r\n    reject(error);\r\n  } finally {\r\n    currentConcurrent--;\r\n    setTimeout(processQueue, 60000 / MAX_RPM);\r\n  }\r\n};\r\n\r\n// Generalized function to perform throttled operations with retries\r\nexport const throttle = async (\r\n  operation: () => Promise<any>,\r\n  options?: any,\r\n) => {\r\n  return new Promise((resolve, reject) => {\r\n    queue.push({ operation, resolve, reject });\r\n    processQueue();\r\n  });\r\n};\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\index.ts\n```typescript\nimport { importPrompts as duneaiImportPrompts } from \"./modules/Prompt\";\r\nimport { createDynamic as duneaiCreateDynamic } from \"./modules/Dynamic\";\r\nimport { Accumulator as duneaiAccumulator , Inverter as duneaiInverter, Selector as duneaiSelector } from \"./modules/Cybernetics\";\r\nimport { TOT as duneaiTOT, COT as duneaiCOT, LAMBDA as duneaiLAMBDA } from \"./modules/constants\";\r\nimport {\r\n  PromptParamsType,\r\n  LifecycleHookType,\r\n  KeyValuePair,\r\n  NestedObjectType,\r\n  DynamicOptionsParamType,\r\n  SelectorOptionsType,\r\n  SelectorParamsType,\r\n  SpiceType,\r\n  MetaType,\r\n  DynamicState,\r\n  PromptType,\r\n  DynamicType,\r\n  SelectorType\r\n} from \"./modules/types\";\r\n\r\nexport type {\r\n  PromptParamsType,\r\n  LifecycleHookType,\r\n  KeyValuePair,\r\n  NestedObjectType,\r\n  DynamicOptionsParamType,\r\n  SelectorOptionsType,\r\n  SelectorParamsType,\r\n  SpiceType,\r\n  MetaType,\r\n  DynamicState,\r\n  PromptType,\r\n  DynamicType,\r\n  SelectorType\r\n}\r\n\r\nexport const createDynamic = duneaiCreateDynamic;\r\nexport const importPrompts = duneaiImportPrompts;\r\nexport const Selector = duneaiSelector;\r\nexport const Accumulator = duneaiAccumulator;\r\nexport const Inverter = duneaiInverter;\r\nexport const TOT = duneaiTOT;\r\nexport const ToT = duneaiTOT;\r\nexport const COT = duneaiCOT;\r\nexport const CoT = duneaiCOT;\r\nexport const LAMBDA = duneaiLAMBDA;\r\n\r\nconst moduleExports = {\r\n  createDynamic,\r\n  importPrompts,\r\n  Selector,\r\n  Accumulator,\r\n  Inverter,\r\n  TOT,\r\n  ToT,\r\n  COT,\r\n  CoT,\r\n  LAMBDA\r\n}\r\n\r\nexport default moduleExports;\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\middleware\\index.ts\n```typescript\nexport { createPersistMiddleware } from \"./persist\";\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\middleware\\logger.ts\n```typescript\ninterface Logger {\r\n  info(message: string): void;\r\n  error(message: string): void;\r\n  warn(message: string): void;\r\n}\r\n\r\n// Define a default logger using console to use if no custom logger is provided\r\nconst defaultLogger: Logger = {\r\n  info: (message) => console.log(message),\r\n  error: (message) => console.error(message),\r\n  warn: (message) => console.warn(message),\r\n};\r\n\r\nexport default {\r\n  info(message: string, ...optionalParams: any[]) {\r\n    console.log(`INFO: ${message}`, ...optionalParams);\r\n  },\r\n\r\n  error(message: string, ...optionalParams: any[]) {\r\n    console.error(`ERROR: ${message}`, ...optionalParams);\r\n  },\r\n\r\n  debug(message: string, ...optionalParams: any[]) {\r\n    console.debug(`DEBUG: ${message}`, ...optionalParams);\r\n  },\r\n};\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\middleware\\persist.ts\n```typescript\nimport fs from \"fs\";\r\nimport path from \"path\";\r\n\r\nconst persistStateToFile = (state: any, filePath: string) => {\r\n  const absolutePath = path.resolve(process.cwd(), filePath);\r\n  fs.writeFileSync(absolutePath, JSON.stringify(state, null, 2));\r\n};\r\n\r\nexport const createPersistMiddleware =\r\n  (filePath: string) => (config: any) => (set: any, get: any, api: any) => {\r\n    const newSet = (partial: any, replace: boolean) => {\r\n      const nextState =\r\n        typeof partial === \"function\" ? partial(get()) : partial;\r\n      set(nextState, replace);\r\n      persistStateToFile(get(), filePath);\r\n    };\r\n    return config(newSet, get, api);\r\n  };\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\modules\\constants.ts\n```typescript\nexport const LAMBDA = 'λ'\r\nexport const COT = 'chain of thought'\r\nexport const TOT = 'tree of thought'\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\modules\\Cybernetics\\Accumulator\\index.ts\n```typescript\nimport { PromptType, KeyValuePair, DynamicState } from \"../../types\";\r\nimport { createPrompt } from \"../../Prompt\";\r\nimport { createDynamic } from \"../../Dynamic\";\r\n\r\nimport { LAMBDA } from \"../../constants\";\r\n\r\nconst DEFAULT_DELIMITER = \",\";\r\n\r\nexport interface OptionsType {\r\n  state?: KeyValuePair;\r\n  context?: KeyValuePair;\r\n  feedback?: string;\r\n  completion?: string;\r\n  aggregate?: string | boolean | ((context?: KeyValuePair, state?: KeyValuePair) => string);\r\n  replicate?: number | ((context?: KeyValuePair, state?: KeyValuePair) => number);\r\n  distribute?: string | boolean | ((context?: KeyValuePair, state?: KeyValuePair) => string);\r\n}\r\n\r\nconst pickName = (prompt: KeyValuePair | PromptType | string): string | false =>\r\n  typeof prompt === \"object\" && \"name\" in prompt && typeof prompt.name === \"string\"\r\n    ? prompt.name\r\n    : typeof prompt === \"object\"\r\n      ? Object.entries(prompt)?.[0]?.[0] || false\r\n      : LAMBDA;\r\n\r\nconst pickContent = (prompt: KeyValuePair | PromptType | string): string | false =>\r\n  typeof prompt === \"object\" && \"content\" in prompt && typeof prompt.content === \"string\"\r\n    ? prompt.content\r\n    : typeof prompt === \"object\"\r\n      ? typeof Object.entries(prompt)?.[0]?.[1] === \"string\" \r\n        ? Object.entries(prompt)[0][1] as string\r\n        : false\r\n      : false;\r\n\r\nconst performReplicate = (\r\n  prompts: (PromptType | KeyValuePair | string)[],\r\n  replicate: number | ((context?: KeyValuePair, state?: KeyValuePair) => number),\r\n  context?: KeyValuePair,\r\n  state?: KeyValuePair,\r\n): Array<Partial<PromptType>> => {\r\n  let replicateCount: number = 0;\r\n\r\n  if (typeof replicate === \"function\") {\r\n    replicateCount = replicate(context, state);\r\n  } else if (typeof replicate === \"number\") {\r\n    replicateCount = replicate;\r\n  }\r\n\r\n  const result: Array<Partial<PromptType>> = [];\r\n\r\n  prompts.forEach((prompt) => {\r\n    const promptName = pickName(prompt);\r\n    const promptContent = pickContent(prompt);\r\n    const promptObject = typeof prompt === \"object\"\r\n      ? prompt\r\n      : { [promptName || LAMBDA]: promptContent };\r\n\r\n    for (let i = 0; i < replicateCount; i++) {\r\n      const newKey = `${promptName}_${i}`;\r\n      result.push({\r\n        ...promptObject,\r\n        name: newKey,\r\n        content: promptContent || '',\r\n        spice: {\r\n          iteration: i,\r\n        }\r\n      });\r\n    }\r\n  });\r\n\r\n  return result;\r\n};\r\n\r\n// an array split by a supplied delemeter.\r\nconst performDistribute = (\r\n  completion: string,\r\n  distribute: string | boolean | ((context?: KeyValuePair, state?: KeyValuePair) => string),\r\n  context?: KeyValuePair,\r\n  state?: KeyValuePair,\r\n): Array<string> => {\r\n  let distributeDelimiter: string = DEFAULT_DELIMITER;\r\n  if (typeof distribute === \"function\") {\r\n    distributeDelimiter = distribute(context, state);\r\n  } else if (typeof distribute === \"string\") {\r\n    distributeDelimiter = distribute;\r\n  } else if (distribute === true) {\r\n    distributeDelimiter = DEFAULT_DELIMITER;\r\n  }\r\n  return completion.split(distributeDelimiter).map((item) => item.trim());\r\n};\r\n\r\nconst performAggregate = (\r\n  completions: string[],\r\n  aggregate: string | boolean | ((context?: KeyValuePair, state?: KeyValuePair) => string),\r\n  context?: KeyValuePair,\r\n  state?: KeyValuePair,\r\n): string => {\r\n  let aggregateDelimiter: string = DEFAULT_DELIMITER;\r\n  if (typeof aggregate === \"function\") {\r\n    aggregateDelimiter = aggregate(context, state);\r\n  } else if (typeof aggregate === \"string\") {\r\n    aggregateDelimiter = aggregate;\r\n  } else if (aggregate === true) {\r\n    aggregateDelimiter = DEFAULT_DELIMITER;\r\n  }\r\n  return completions.join(aggregateDelimiter);\r\n};\r\n\r\n// Changes string into an array and then back into a sorted list as an array\r\n// Accumulator('colors: 1) blue, 2) orange, 3) red', { distribute, aggregate })\r\n// returns: blue, orange, red\r\nexport const Accumulator = async({\r\n  basePrompts,\r\n  options\r\n}: {\r\n  basePrompts: (string | KeyValuePair | PromptType)[],\r\n  options: OptionsType\r\n}): Promise<string | string[] | PromptType[]> => {\r\n\r\n  let prompts: (string | KeyValuePair | PromptType)[] = [...basePrompts];\r\n  let completion: string | string[] = options.completion || '';\r\n  let completions: string | string[];\r\n\r\n  const { replicate, aggregate, distribute, context, state } =\r\n    options;\r\n\r\n  // valid combos:\r\n  // replicate: true  | replicate: false | replicate: false\r\n  // aggregate: true  | aggregate: true  | aggregate: false\r\n  // distribute: true | distribute: true | distribute: true\r\n  //\r\n  // invalid combo (can't do this, replacate creates array and distribute can't consume that)\r\n  // replicate: true\r\n  // aggregate: false\r\n  // distribute: true\r\n\r\n  prompts = replicate\r\n    ? performReplicate(prompts, replicate, context, state) as PromptType[]\r\n    : prompts;\r\n\r\n  completions = distribute\r\n    ? performDistribute(completion, distribute, context, state)\r\n    : [completion as string];\r\n\r\n  completion = aggregate\r\n    ? performAggregate(completions, aggregate, context, state)\r\n    : completions;\r\n\r\n  if(completions[0] !== '') {\r\n    return completions as string[];\r\n  }\r\n\r\n  if(completion !== '' && completion[0] !== '') {\r\n    return completion as string;\r\n  }\r\n\r\n  return prompts as PromptType[];\r\n};\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\modules\\Cybernetics\\index.ts\n```typescript\nimport { Accumulator } from \"./Accumulator\";\r\nimport { Selector } from \"./Selector\";\r\nimport { Inverter } from \"./Inverter\";\r\n// import { ThinkingMachine } from \"./ThinkingMachine\";\r\n\r\nconst LAMBDA = \"λ\";\r\n\r\n// // Define the base Cybernetic type with shared attributes and methods\r\n// export interface Cybernetic {\r\n//   prompt: string;\r\n//   options: Record<string, unknown>;\r\n// }\r\n\r\n// // Base cybernetic function that could be extended or used for shared functionality\r\n// export const BaseCybernetic = (\r\n//   prompt: string,\r\n//   options: Record<string, unknown>,\r\n// ): Cybernetic => ({\r\n//   prompt,\r\n//   options,\r\n// });\r\n\r\n// Export all cybernetics for use elsewhere in the application\r\nexport { Selector, Accumulator, Inverter, LAMBDA }; //, Inverter, ThinkingMachine };\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\modules\\Cybernetics\\Inverter\\index.ts\n```typescript\nimport { createDynamic } from '../../Dynamic'\r\nimport { LAMBDA } from '../index'\r\nimport { \r\n  DynamicState\r\n} from '../../types'\r\n\r\nconst defaultCriteria = '\"truthy\" or \"falsey\"'\r\nconst prompt = (criteria: string, completion: string) => \r\n  `is this criteria, ${criteria}, false for this completion: ${completion}? \r\n  respond with t for true or f for false.`\r\n\r\nexport const Inverter = async({\r\n  completion,\r\n  criteria\r\n}: { \r\n  completion: string, \r\n  criteria?: string\r\n}): Promise<boolean> => {\r\n  const dynamic = createDynamic(\r\n    'InverterCybernetic', {}, \r\n    [prompt(criteria || defaultCriteria, completion)]\r\n);\r\n  const result: DynamicState[\"state\"] = await dynamic.run({});\r\n  return result?.['InverterCybernetic']?.[LAMBDA]?.includes('t') || false;\r\n};\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\modules\\Cybernetics\\Selector\\index.ts\n```typescript\nimport { createDynamic } from '../../Dynamic'\r\nimport { LAMBDA } from '../index'\r\nimport { \r\n  SelectorParamsType, \r\n  DynamicState, \r\n  SelectorOptionsType \r\n} from '../../types'\r\n\r\nconst defaultCriteria = '\"truthy\" or \"falsey\"'\r\nconst prompt = (criteria: string, completion: string) => \r\n  `is this criteria, ${criteria}, true for this completion: ${completion}? \r\n  respond with t for true or f for false.`\r\n\r\nconst greedySelector = async({\r\n  completions,\r\n  criteria\r\n}: { \r\n  completions: string[], \r\n  criteria: string\r\n}): Promise<[number, string] | []> => {\r\n  let selected: [number, string] | [] = []\r\n  for (const [index, completion] of completions.entries()) {\r\n    const dynamic = createDynamic('SelectorCybernetic', {}, [prompt(criteria, completion)]);\r\n    const result: DynamicState[\"state\"] = await dynamic.run({});\r\n    if (result?.['SelectorCybernetic']?.[LAMBDA]?.includes('t')) {\r\n      selected = [index, completion];\r\n      break;\r\n    }\r\n  }\r\n  return Promise.resolve(selected);\r\n}\r\n\r\nconst generousSelector = async({\r\n  completions,\r\n  criteria\r\n}: { \r\n  completions: string[], \r\n  criteria: string\r\n}): Promise<([number, string] | [])[]> => {\r\n  const results = await Promise.all(completions.map(async (completion, index) => {\r\n    const dynamic = createDynamic('SelectorCybernetic', {}, [prompt(criteria, completion)])\r\n    const result: DynamicState[\"state\"] = await dynamic.run({})\r\n    if (result?.['SelectorCybernetic']?.[LAMBDA]?.includes('t')) {\r\n      return [index, completion]\r\n    }\r\n    return [];\r\n  }));\r\n\r\n  return results.filter(result => result.length > 0) as [number, string][];\r\n}\r\n\r\nexport const Selector = async({\r\n  completions,\r\n  criteria,\r\n  options\r\n}: SelectorParamsType): Promise<[number, string] | [] | ([number, string] | [])[]> => {\r\n  const resolvedCompletions: string[] = typeof completions === 'function' \r\n    ? completions((options as SelectorOptionsType)?.state as DynamicState[\"state\"]) \r\n    : completions;\r\n  const resolvedCriteria: string = typeof criteria === 'function' \r\n    ? criteria((options as SelectorOptionsType)?.state as DynamicState[\"state\"]) \r\n    : criteria || defaultCriteria;\r\n\r\n  return options?.greedy === true || options?.greedy === undefined\r\n    ? await greedySelector({ \r\n      completions: resolvedCompletions, \r\n      criteria: resolvedCriteria\r\n    }) \r\n    : await generousSelector({ \r\n      completions: resolvedCompletions, \r\n      criteria: resolvedCriteria\r\n    })\r\n};\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\modules\\Dynamic\\dependencies.ts\n```typescript\nimport { DynamicType, DynamicState, NestedObjectType } from \"../types\";\r\nimport { createPrompt } from \"../Prompt\";\r\nimport { COT } from \"../constants\";\r\nimport { useStore } from \"../../store\";\r\n\r\nexport const run = async (\r\n  initialState: Record<string, any>,\r\n  dynamic: DynamicType,\r\n) => {\r\n  const { initializeState, setContext } = useStore.getState();\r\n\r\n  initializeState(initialState);\r\n\r\n  // @ts-ignore\r\n  setContext(dynamic?.context as NestedObjectType);\r\n\r\n  if (dynamic.before) {\r\n    const beforeResult = \r\n      (await dynamic.before(useStore.getState().state as DynamicState)) as object;\r\n    initializeState(beforeResult as NestedObjectType);\r\n  }\r\n\r\n  const strategy =\r\n    dynamic.kind === COT\r\n      ? runChainOfThought\r\n      : runTreeOfThought;\r\n\r\n  await strategy(dynamic);\r\n\r\n  if (dynamic.after) {\r\n    const afterResult = (await dynamic.after({\r\n      ...useStore.getState().state,\r\n    })) as object;\r\n    initializeState(afterResult as NestedObjectType);\r\n  }\r\n\r\n  return useStore.getState().state;\r\n}\r\n\r\nconst runChainOfThought = async (dynamic: DynamicType) => {\r\n  for (const prompt of dynamic.prompts || []) {\r\n    const { state, context } = useStore.getState();\r\n    const promptObject = await createPrompt(prompt)\r\n    const generation = await promptObject.run({\r\n      ...state,\r\n      context,\r\n    } as DynamicState, dynamic.log);\r\n    useStore.getState().setState(\r\n      dynamic.name, \r\n      generation.name, \r\n      generation.completion as string,\r\n      dynamic.log ? generation.spice : false\r\n    );\r\n  }\r\n}\r\n\r\nconst runTreeOfThought = async (dynamic: DynamicType) => {\r\n  await Promise.all(dynamic.prompts.map(async (prompt) => {\r\n    const { state, context } = useStore.getState();\r\n    const promptObject = await createPrompt(prompt)\r\n    const generation = await promptObject.run({\r\n      ...state,\r\n      context: context as NestedObjectType,\r\n    } as DynamicState, dynamic.log);\r\n    useStore.getState().setState(\r\n      dynamic.name, \r\n      generation.name, \r\n      generation.completion as string,\r\n      dynamic.log ? generation.spice : false\r\n    );\r\n  }));\r\n}\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\modules\\Dynamic\\index.ts\n```typescript\nimport { run } from \"./dependencies\";\r\nimport { COT, TOT, LAMBDA } from \"../constants\";\r\nimport { \r\n  DynamicType, \r\n  NestedObjectType, \r\n  PromptParamsType, \r\n  DynamicOptionsParamType, \r\n  DynamicState\r\n} from \"../types\";\r\n\r\nexport const createDynamic = (\r\n  options: DynamicOptionsParamType | string,\r\n  context?: NestedObjectType,\r\n  prompts?: Array<PromptParamsType>,\r\n  overrides?: Partial<PromptParamsType>\r\n): DynamicType => {\r\n  let newDynamic: DynamicType;\r\n\r\n  if (typeof options === \"string\") {\r\n    newDynamic = {\r\n      name: options as string,\r\n      kind: COT,\r\n      context: context as NestedObjectType,\r\n      prompts: prompts as Array<PromptParamsType>,\r\n      log: false,\r\n    } as DynamicType;\r\n  } else if (typeof options === \"object\") {\r\n    newDynamic = {\r\n      name: options.name ?? LAMBDA,\r\n      kind: options.kind === TOT ? TOT : COT,\r\n      context: options.context as NestedObjectType,\r\n      prompts: options.prompts as Array<PromptParamsType>,\r\n      log: options.log ?? false,\r\n      before: options.before,\r\n      after: options.after,\r\n    } as DynamicType;\r\n  } else {\r\n    throw new Error(\"Invalid dynamic params\");\r\n  }\r\n\r\n  return {\r\n    ...newDynamic,\r\n    overrides: overrides ?? overrides,\r\n    run: (initialState?: NestedObjectType): Promise<Partial<DynamicState>> => \r\n      run(initialState as NestedObjectType, newDynamic),\r\n  }\r\n}\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\modules\\Prompt\\dependencies.ts\n```typescript\nimport path from \"path\";\r\nimport fs from \"fs\";\r\nimport Mustache from \"mustache\";\r\n\r\nimport { PromptType, DynamicState } from \"../types\";\r\nimport { LAMBDA } from \"../constants\";\r\nimport { ask } from \"../../adapter\";\r\nimport { getSettings } from \"../settings\";\r\nimport { countTokens } from \"../../utils\";\r\nimport Logger from \"../../middleware/logger\";\r\nimport { KeyValuePair } from \"../types\";\r\n\r\nexport const run = async(prompt: PromptType, state: DynamicState, log: boolean) => {\r\n  let runningPrompt: PromptType = prompt;\r\n  runningPrompt = prefixSpice(runningPrompt);\r\n  runningPrompt = interpolateSpice(runningPrompt);\r\n  runningPrompt = interpolateState(runningPrompt, state);\r\n\r\n  if (log) logPrompt(prompt, 'sending', runningPrompt.content as string);\r\n  const completion = await performCompletion(runningPrompt) as { content: string, meta: any };\r\n  if (log) logPrompt(prompt, 'received', completion.content as string);\r\n\r\n  return Promise.resolve({\r\n    // @ts-ignore\r\n    ...runningPrompt,\r\n    ...suffixSpice(runningPrompt, completion.content || '', completion || {}),\r\n    completion: completion.content,\r\n  });\r\n}\r\n\r\nconst logPrompt = (prompt: PromptType, status: 'sending' | 'received', content: string) => {\r\n  const maxLength = parseInt(getSettings().maxLogLength as string, 10);\r\n  const contentWithoutNewlines = content.replace(/\\n/g, '');\r\n  const preview = contentWithoutNewlines.length > maxLength \r\n    ? contentWithoutNewlines.substring(0, maxLength) + '...' \r\n    : contentWithoutNewlines;\r\n  const { tokenCount} = countTokens(content, 'gpt-4o-mini');\r\n  const prefix = `${status.toUpperCase()} (${tokenCount.toLocaleString()})`;\r\n  const paddedPrefix = prefix.padEnd(15, ' ');\r\n  const paddedName = prompt.name.padEnd(25, ' ');\r\n  const message = `${paddedPrefix} | ${paddedName} | ${preview}`;\r\n  Logger.info(message);\r\n}\r\n\r\nfunction getCallerFile(): string {\r\n  const originalFunc = Error.prepareStackTrace;\r\n\r\n  try {\r\n    const err = new Error();\r\n    let callerfile: string | undefined;\r\n\r\n    Error.prepareStackTrace = function (err, stack) { return stack; };\r\n\r\n    const currentfile = (err.stack as unknown as NodeJS.CallSite[]).shift()!.getFileName();\r\n\r\n    while (err.stack && (err.stack as unknown as NodeJS.CallSite[]).length) {\r\n      const caller = (err.stack as unknown as NodeJS.CallSite[]).shift()!;\r\n      callerfile = caller.getFileName();\r\n\r\n      if (currentfile !== callerfile) {\r\n        return callerfile!;\r\n      }\r\n    }\r\n  } catch (e) {\r\n  } finally {\r\n    Error.prepareStackTrace = originalFunc;\r\n  }\r\n\r\n  return \"\";\r\n}\r\n\r\nexport const importPrompts = (\r\n  dirOrFilePath: string,\r\n): Record<string, string> => {\r\n  const callerFile = getCallerFile();\r\n  const callerDir = path.dirname(callerFile);\r\n\r\n  const absolutePath = path.resolve(callerDir, dirOrFilePath);\r\n\r\n  if (fs.lstatSync(absolutePath).isDirectory()) {\r\n    const prompts: Record<string, string> = {};\r\n    const filePaths = fs\r\n      .readdirSync(absolutePath)\r\n      .filter((file) => file.endsWith(\".prompt\"));\r\n\r\n    filePaths.forEach((filePath) => {\r\n      const fileName = path.basename(filePath, path.extname(filePath));\r\n      prompts[fileName] = importPrompt(path.join(absolutePath, filePath));\r\n    });\r\n\r\n    return prompts;\r\n  } else {\r\n    const content = importPrompt(absolutePath);\r\n    return parsePromptsFromFile(content);\r\n  }\r\n};\r\n\r\nconst importPrompt = (filePath: string): string => {\r\n  return fs.readFileSync(filePath, \"utf8\");\r\n};\r\n\r\nconst interpolateSpice = (prompt: PromptType): PromptType => {\r\n  const interpolate = (content: string, params: Record<string, any>): string => {\r\n    const keys = Object.keys(params);\r\n    const values = Object.values(params);\r\n    return new Function(...keys, `return \\`${content}\\`;`)(...values);\r\n  };\r\n\r\n  const content = interpolate(prompt.content, prompt.spice);\r\n\r\n  return {\r\n    ...prompt,\r\n    content,\r\n  };\r\n}\r\n\r\nconst prefixSpice = (prompt: PromptType): PromptType => {\r\n  const startedAt = new Date();\r\n  const currentTime = new Date();\r\n  const seed = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\r\n  return {\r\n    ...prompt,\r\n    spice: {\r\n      ...prompt.spice,\r\n      currentTime,\r\n      startedAt,\r\n      seed,\r\n    },\r\n  };\r\n}\r\n\r\nconst suffixSpice = (prompt: PromptType, completion: string, raw: KeyValuePair): PromptType => {\r\n  const finishedAt = new Date();\r\n  const duration = \r\n    (finishedAt.getTime() - \r\n    (prompt.spice?.startedAt?.getTime() || 0));\r\n  const { tokenCount: tokensSent } =\r\n    countTokens(prompt.content, prompt.model as string);\r\n  const { tokenCount: tokensReceived } =\r\n    countTokens(completion, prompt.model as string);\r\n\r\n  const totalTokens = tokensSent + tokensReceived;\r\n    \r\n  return {\r\n    ...prompt,\r\n    spice: {\r\n      ...prompt.spice,\r\n      sentPrompt: prompt.content,\r\n      finishedAt,\r\n      duration,\r\n      modelUsed: prompt.model,\r\n      adapterUsed: prompt.adapter || 'openai',\r\n      tokensSent,\r\n      tokensReceived,\r\n      totalTokens,\r\n      raw,\r\n    },\r\n  };\r\n}\r\n\r\nconst interpolateState = (prompt: PromptType, state: DynamicState): PromptType => {\r\n  const content = Mustache.render(prompt.content as string, {\r\n    ...state,\r\n    ...{\r\n      C: state.context,\r\n      c: state.context,\r\n      Context: state.context,\r\n      context: state.context,\r\n    },\r\n  });\r\n  return {\r\n    ...prompt,\r\n    content,\r\n  };\r\n}\r\n\r\nconst performCompletion = async(prompt: PromptType) => {\r\n  return await ask(prompt.content, prompt.adapter, prompt.model, prompt.options);\r\n}\r\n\r\nconst parsePromptsFromFile = (\r\n  content: string,\r\n): Record<string, string> => {\r\n  const prompts: Record<string, string> = {};\r\n  const sections = content.split(/^#\\s*(\\w+)/gm);\r\n\r\n  for (let i = 1; i < sections.length; i += 2) {\r\n    const name = sections[i];\r\n    const promptContent = sections[i + 1].trim();\r\n    prompts[name] = promptContent;\r\n  }\r\n\r\n  return prompts;\r\n};\r\n\r\nexport const stringToPrompt = (\r\n  content: string\r\n): Partial<PromptType> => {\r\n  return {\r\n    name: LAMBDA,\r\n    content,\r\n  } as Partial<PromptType>;\r\n}\r\n\r\nexport const keyValuePairToPrompt = (\r\n  name: string, \r\n  content: string\r\n): Partial<PromptType> => {\r\n  return {\r\n    name,\r\n    content,\r\n  } as Partial<PromptType>;\r\n}\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\modules\\Prompt\\index.ts\n```typescript\nimport { PromptType, PromptParamsType, DynamicState } from \"../types\";\r\nimport { getSettings } from \"../settings\";\r\nimport { \r\n  run, \r\n  importPrompts, \r\n  stringToPrompt, \r\n  keyValuePairToPrompt \r\n} from \"./dependencies\";\r\n  \r\nconst createPrompt = async(\r\n  params: PromptParamsType\r\n): Promise<PromptType> => {\r\n  let newPrompt: Partial<PromptType>;\r\n\r\n  if (typeof params === 'function') {\r\n    return createPrompt(await params());\r\n  } else {\r\n    if (typeof params === 'string') {\r\n      newPrompt = stringToPrompt(params as string);\r\n    } else if (typeof params === 'object' && !params?.name) {\r\n      const [name, content] = Object.entries(params)[0];\r\n      newPrompt = keyValuePairToPrompt(name, content);\r\n    } else if (typeof params === 'object') {\r\n      newPrompt = params as Partial<PromptType>;\r\n    } else {\r\n      throw new Error('Invalid prompt params');\r\n    }\r\n  }\r\n\r\n  return {\r\n    ...getSettings(),\r\n    ...newPrompt,\r\n    run: (state: DynamicState, log: boolean = false) => run(newPrompt as PromptType, state, log)\r\n  } as PromptType;\r\n}\r\n\r\nexport { importPrompts, createPrompt };\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\modules\\settings.ts\n```typescript\n// @ts-ignore\r\nimport dotenv from 'dotenv';\r\ndotenv.config();\r\n\r\nexport const getSettings = () => ({\r\n  model: process.env.DEFAULT_MODEL || \"gpt-4o-mini\",\r\n  adapter: process.env.DEFAULT_ADAPTER || \"openai\",\r\n  maxLogLength: process.env.MAX_LOG_LENGTH || '25',\r\n});\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\modules\\types.ts\n```typescript\ntype SimplePrompt = string;\r\ntype KeyValuePrompt = KeyValuePair;\r\n\r\nexport type PromptParamsType = \r\n  PromptType      | \r\n  SimplePrompt    | \r\n  KeyValuePrompt  | \r\n  (() => PromptType | SimplePrompt | KeyValuePrompt) |\r\n  (() => Promise<PromptType | SimplePrompt | KeyValuePrompt>);\r\n\r\nexport type LifecycleHookType = (state: Partial<DynamicState>) => \r\n  void          | \r\n  Promise<void> | \r\n  Promise<Partial<DynamicState>>;\r\n\r\nexport interface KeyValuePair {\r\n  [key: string]: \r\n    string | \r\n    number | \r\n    boolean;\r\n}\r\n\r\nexport interface NestedObjectType {\r\n  [key: string]: \r\n    string  | \r\n    number  | \r\n    boolean |\r\n    NestedObjectType;\r\n}\r\n\r\nexport interface DynamicOptionsParamType {\r\n  kind: string;\r\n  prompts: PromptParamsType[];\r\n  context?: NestedObjectType;\r\n  overrides?: Partial<PromptParamsType>;\r\n  name?: string;\r\n  meta?: MetaType;\r\n  log?: boolean;\r\n  before?: LifecycleHookType;\r\n  after?: LifecycleHookType;\r\n}\r\n\r\nexport type SelectorOptionsType = {\r\n  greedy?: boolean;\r\n  state?: DynamicState['state'];\r\n}\r\n\r\nexport type SelectorParamsType = {\r\n  completions: \r\n    string[] | \r\n    ((state: DynamicState['state']) => string[]);\r\n  criteria?: \r\n    string |\r\n    ((state: DynamicState['state']) => string);\r\n  options?: SelectorOptionsType;\r\n}\r\n\r\nexport interface SpiceType {\r\n  sentPrompt?: string;\r\n  seed?: number;\r\n  currentTime?: Date;\r\n  startedAt?: Date;\r\n  iteration?: number;\r\n  finishedAt?: Date;\r\n  duration?: number;\r\n  tokensSent?: number;\r\n  tokensReceived?: number;\r\n  totalTokens?: number;\r\n  modelUsed?: string;\r\n  adapterUsed?: string;\r\n  raw?: KeyValuePair;\r\n}\r\n\r\nexport interface MetaType {\r\n  startedAt: Date;\r\n  completedAt: Date;\r\n  duration: number;\r\n  tokensSent: number;\r\n  tokensReceived: number;\r\n  totalTokens: number;\r\n}\r\n\r\nexport interface DynamicState {\r\n  state: Record<string, any>;\r\n  context: NestedObjectType;\r\n  setState: (\r\n    dynamicName: string, \r\n    promptName: string, \r\n    value: string, \r\n    spice: SpiceType | boolean\r\n  ) => void;\r\n  setContext: (\r\n    dynamicName: string, \r\n    promptName: string, \r\n    value: any, \r\n    spice: SpiceType | boolean\r\n  ) => void;\r\n  initializeState: (initialState: NestedObjectType) => void;\r\n}\r\n\r\nexport interface PromptType {\r\n  name: string;\r\n  model: string;\r\n  adapter: string;\r\n  content: string;\r\n  completion?: string;\r\n  spice: SpiceType;\r\n  options: KeyValuePair;\r\n  run: (state: DynamicState, log: boolean) => \r\n    Promise<PromptType>;\r\n}\r\n\r\nexport interface DynamicType {\r\n  name: string;\r\n  kind: string;\r\n  log: boolean;\r\n  meta: MetaType;\r\n  context: NestedObjectType;\r\n  prompts: PromptParamsType[];\r\n  overrides?: Partial<PromptParamsType>;\r\n  before?: LifecycleHookType;\r\n  after?: LifecycleHookType;\r\n  exportState: () => DynamicState;\r\n  run: (state?: NestedObjectType) => \r\n    Promise<Partial<DynamicState>>;\r\n}\r\n\r\nexport interface SelectorType {\r\n  (params: SelectorParamsType): Promise<\r\n    [number, string][] |\r\n    [number, string]\r\n  >;\r\n}\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\scripts\\generators\\index.ts\n```typescript\nexport const createDynamic = () => {}\r\n\r\nexport const createPrompt = () => {}\r\n\r\nexport const createFactory = () => {}\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\scripts\\orchistrations\\GenerateReadme\\index.ts\n```typescript\nimport fs from 'fs';\r\nimport path from 'path';\r\n\r\n// @ts-ignore\r\nimport { createDynamic, importPrompts, COT } from \"duneai\";\r\n\r\n\r\nconst fullPath = path.resolve(__dirname, \"./prompts.prompt\");\r\nconst { Structure, Section, Edit } = importPrompts(fullPath);\r\n\r\nexport const StructureDynamic = (context: any) => createDynamic({\r\n  name: 'Structure',\r\n  kind: COT,\r\n  context,\r\n  prompts: [{ Structure }]\r\n});\r\n\r\nexport const SectionDynamic = (context: any) => createDynamic({\r\n  name: 'SectionDynamic',\r\n  kind: COT,\r\n  context,\r\n  prompts: [{ [context.currentSection.trim()]: Section }]\r\n});\r\n\r\nexport const EditDynamic = (context: any) => createDynamic({\r\n  name: 'EditDynamic',\r\n  kind: COT,\r\n  context,\r\n  prompts: [{ Edit }]\r\n});\r\n\r\nconst introduction = `\r\nDuneAI: The World's First Open Source Cybernetic Orchestration Framework\r\n\r\nDuneAI is a breakthrough in artificial intelligence orchestration, built on the principles of cybernetics. As the world’s first open-source Cybernetic Orchestration Framework, DuneAI offers a new level of intelligence, flexibility, and adaptability to AI workflows. Unlike conventional systems, DuneAI enables AI to analyze its own outputs and adjust future actions, resulting in self-evolving, adaptive systems.\r\n\r\nWhat makes DuneAI unique is its ability to form cybernetic feedback loops—allowing AI to continuously refine its behavior based on its outputs. While traditional frameworks focus on chaining operations or retrieving data, DuneAI empowers AI to learn from its results and modify its decision-making process autonomously. This makes DuneAI particularly effective for complex workflows that require ongoing adaptation.\r\nThe Core of DuneAI\r\n\r\nDuneAI’s functionality is built around two core constructs: Dynamics and Prompts.\r\n\r\n    Dynamics are reusable, state-aware components that manage how workflows are executed. They adapt based on the AI's evolving state, allowing for flexible orchestration.\r\n\r\n    Prompts are modular commands that interface with AI models. Enhanced with Mustache syntax, Prompts allow dynamic state injection at runtime, ensuring interactions evolve as workflows progress. Prompts not only retrieve outputs but also shape the workflow in response to real-time state changes.\r\n\r\nThese constructs work together to enable adaptive orchestration, where workflows adjust and refine themselves through cybernetic feedback.\r\nA New Approach to AI Orchestration\r\n\r\nDuneAI offers a fresh approach to AI orchestration, focusing on self-refining workflows that evolve through continuous feedback. This adaptive capability goes beyond what is offered by traditional frameworks, providing more intelligent, autonomous systems for handling dynamic tasks.\r\n\r\nDuneAI is licensed under the MIT license and was created by Kenan Stipek with the support of the team at AllusionLabs. This README was written by Kenan Stipek and generated by DuneAI itself, using OpenAI’s GPT-4o-mini model to process DuneAI’s own source code.\r\n`;\r\n\r\n\r\nconst generateReadme = async () => {\r\n  const sourceDir = path.resolve(__dirname, '../..');\r\n  const readmePath = path.join(sourceDir, 'README.md');\r\n\r\n  // Function to read the source code files\r\n  const readSourceFiles = (dir: string): string[] => {\r\n    let results: string[] = [];\r\n    const gitignorePath = path.resolve(__dirname, '../../../.gitignore');\r\n    const gitignorePatterns = fs.readFileSync(gitignorePath, 'utf8')\r\n      .split('\\n')\r\n      .filter((line) => line && !line.startsWith('#'))\r\n      .map((pattern) => new RegExp(pattern.replace(/\\*/g, '.*')));\r\n\r\n    const isIgnored = (file: string) => {\r\n      return gitignorePatterns.some((pattern) => pattern.test(file));\r\n    };\r\n\r\n    const list = fs.readdirSync(dir);\r\n    list.forEach((file) => {\r\n      file = path.join(dir, file);\r\n      if (isIgnored(file)) {\r\n        return;\r\n      }\r\n      const stat = fs.statSync(file);\r\n      if (stat && stat.isDirectory()) {\r\n        results = results.concat(readSourceFiles(file));\r\n      } else if (file.endsWith('.ts') || file.endsWith('.js')) {\r\n        results.push(file);\r\n      }\r\n    });\r\n    return results;\r\n  };\r\n\r\n  // Function to extract relevant information from the source code\r\n  const extractInfoFromSource = async (files: string[]): Promise<string> => {\r\n    let info = '';\r\n    files.forEach((file) => {\r\n      const content = fs.readFileSync(file, 'utf8');\r\n      info += `\\n\\n### ${file}\\n\\`\\`\\`typescript\\n${content}\\n\\`\\`\\`\\n`;\r\n    });\r\n    return info;\r\n  };\r\n\r\n  // Read all source files\r\n  const sourceFiles = readSourceFiles(sourceDir);\r\n\r\n  // Extract information from the source files\r\n  const extractedInfo = await extractInfoFromSource(sourceFiles);\r\n\r\n  const structure = await StructureDynamic({ extractedInfo, introduction }).run({});\r\n  let allSections = '';\r\n  // @ts-ignore\r\n  for (const rawCurrentSection of structure.Structure.Structure.split(',')) {\r\n    const currentSection = rawCurrentSection.trim()\r\n    const sectionContent = await SectionDynamic({ extractedInfo, structure, currentSection, allSections, introduction }).run({});\r\n    // @ts-ignore\r\n    allSections += sectionContent.SectionDynamic[currentSection];\r\n  }\r\n\r\n  const edit = await EditDynamic({ allSections: `${introduction}\\n\\n${allSections}` }).run({});\r\n  // @ts-ignore\r\n  const finalCopy = edit.EditDynamic.Edit\r\n\r\n  // Write the extracted information to the README.md file\r\n  fs.writeFileSync(readmePath, finalCopy);\r\n};\r\n\r\n// Run the generateReadme function\r\ngenerateReadme().then(() => {\r\n  console.log('README.md has been generated successfully.');\r\n}).catch((error) => {\r\n  console.error('Error generating README.md:', error);\r\n});\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\scripts\\orchistrations\\PoemWriter\\dynamics\\index.ts\n```typescript\nimport * as path from \"path\";\r\n// @ts-ignore\r\nimport { createDynamic, importPrompts, TOT } from \"duneai\";\r\n\r\n\r\nconst fullPath = path.resolve(__dirname, \"../prompts/Prompts.prompt\");\r\nconst { Continent, Languages, HelloWorld, Respond } = importPrompts(fullPath);\r\n\r\nconst COUNT = 4;\r\n\r\nconst context = { count: COUNT };\r\n\r\nconst PickLocale = createDynamic(\"PickLocale\", context, [\r\n  {\r\n    name: \"Continent\",\r\n    content: Continent,\r\n    model: \"gpt-4o-mini\",\r\n  },\r\n  { Languages },\r\n]);\r\nconst RespondToAll = createDynamic(\"RespondToAll\", context, [{ Respond }]);\r\n\r\nexport const SayHelloWorld = createDynamic({\r\n  name: \"SayHelloWorld\",\r\n  kind: TOT,\r\n  context,\r\n  prompts: [{ HelloWorld }],\r\n  before: async (state: any) => await PickLocale.run(state),\r\n  after: async (state: any) => await RespondToAll.run(state),\r\n});\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\scripts\\orchistrations\\PoemWriter\\index.ts\n```typescript\n// @ts-ignore\r\nimport { createDynamic, TOT } from \"duneai\";\r\n\r\nconst ideaCount = 3;\r\nconst scale = 100;\r\nconst models = ['gpt-4o', 'gpt-4', 'gpt-4o-mini'];\r\n\r\n(async () => {\r\n\r\n  // Come up with a list of poem ideas from each model and put them in a list.\r\n  const prompt = 'Write me a list of {{ context.ideaCount }} poem ideas, only the list, comma separated';\r\n  const PoemIdeaDynamic = createDynamic('PoemIdeaDynamic', { ideaCount }, models.map((model) => ({\r\n    name: model,\r\n    content: prompt,\r\n    model,\r\n    kind: TOT,\r\n    log: true\r\n  })));\r\n  const ideas = await PoemIdeaDynamic.run({}) as any;\r\n  const ideasArray = Object.values(ideas.PoemIdeaDynamic)\r\n    .join(',').split(',').map((idea: string) => idea.trim());\r\n    \r\n  // Create a prompt for each poem idea and write a poem about it\r\n  const poemPrompts = models.map((model) => \r\n    ideasArray.map((idea: string) => ({ \r\n      name: `${model}-${idea}`,\r\n      content: `Without mentioning the title, write a poem about: ${idea}`, \r\n      model,\r\n    }))\r\n  )\r\n\r\n  const PoemWriterDynamic = createDynamic({\r\n    name: 'PoemWriterDynamic', \r\n    prompts: poemPrompts.reduce((acc, val) => acc.concat(val), []),\r\n    kind: TOT,\r\n    log: true\r\n  });\r\n  const poemResults = await PoemWriterDynamic.run({});\r\n\r\n  // Rate the poems\r\n  const rubric = `\r\n    rate this poem on a scale of 1 to ${scale}, \r\n    consider the creativity, depth, and emotional impact, \r\n    only return the rating: ${poemResults}\r\n  `;\r\n\r\n  // const ratePoemsPrompts\r\n\r\n  console.log(poemResults);\r\n\r\n  // // Rate the poems\r\n  // const justPoems = Object.values(poems).map(poem => poem.PoemWriterDynamic)\r\n  // const ratingPrompts = justPoems.map((poem, index) => ({ \r\n  //   [index]: `\r\n  //     rate this poem on a scale of 1 to {{ context.scale }}, \r\n  //     consider the creativity, depth, and emotional impact, \r\n  //     only return the rating: ${poem}` \r\n  // } ))\r\n  // const PoemRatingsDynamic = createDynamic({\r\n  //   name: 'PoemRatingsDynamic', \r\n  //   prompts: ratingPrompts,\r\n  //   context: { scale },\r\n  //   kind: TOT,\r\n  //   log: true\r\n  // });\r\n  // const poemRatings = await PoemRatingsDynamic.run({}) as any;\r\n\r\n  // // Sort the poems by rating and get the short list\r\n  // const sortedPoems = Object.entries(poemRatings.PoemRatingsDynamic)\r\n  //   .sort(([, ratingA], [, ratingB]) => parseInt(ratingB as string) - parseInt(ratingA as string))\r\n  //   .map(([index]) => justPoems[parseInt(index)]);\r\n  // const bestPoem = sortedPoems[0]\r\n\r\n  // // name the best poem\r\n  // const namePrompt = `name this poem, return only the name: ${bestPoem}`;\r\n  // const PoemNamerDynamic = createDynamic('PoemNamerDynamic', {}, [namePrompt]);\r\n  // const result = await PoemNamerDynamic.run({}) as any;\r\n  // const name = result.PoemNamerDynamic[LAMBDA];\r\n\r\n  // console.log(\"My favorite poem that I wrote is:\\n\");\r\n  // console.log(name);\r\n  // console.log(\"\\n\");\r\n  // console.log(bestPoem);\r\n})();\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\scripts\\orchistrations\\SummarizePullRequests\\index.ts\n```typescript\nimport fs from 'fs';\r\nimport {ChatSession} from \"gpt4all\";\r\nimport path from 'path';\r\n\r\n// @ts-ignore\r\nimport { createDynamic, importPrompts, COT } from \"src/index\";\r\n\r\n\r\nconst fullPath = path.resolve(__dirname, \"./prompts.prompt\");\r\nconst { Structure, Section, Edit } = importPrompts(fullPath);\r\n\r\nexport const summarizePullRequest = async (session: ChatSession) => {\r\n  const sourceDir = path.resolve(process.cwd(), 'src');\r\n\r\n  const StructureDynamic = (context: any) => createDynamic({\r\n    name: 'StructureDynamic',\r\n    kind: COT,\r\n    context,\r\n    prompts: [{\r\n      Structure,\r\n      adapter: 'gpt4all',\r\n      model: 'n/a',\r\n      // @ts-ignore\r\n      options: {\r\n        session\r\n      }\r\n    }],\r\n  });\r\n\r\n  const SectionDynamic = (context: any) => createDynamic({\r\n    name: 'SectionDynamic',\r\n    kind: COT,\r\n    context,\r\n    prompts: [{\r\n      [context.currentSection.trim()]: Section,\r\n      adapter: 'gpt4all',\r\n      model: 'n/a',\r\n      // @ts-ignore\r\n      options: {\r\n        session\r\n      }\r\n    }],\r\n  });\r\n\r\n  const EditDynamic = (context: any) => createDynamic({\r\n    name: 'EditDynamic',\r\n    kind: COT,\r\n    context,\r\n    prompts: [{\r\n      Edit,\r\n      adapter: 'gpt4all',\r\n      model: 'n/a',\r\n      // @ts-ignore\r\n      options: {\r\n        session\r\n      }\r\n    }],\r\n  });\r\n\r\n  // Function to read the source code files\r\n  const readSourceFiles = (dir: string): string[] => {\r\n    let results: string[] = [];\r\n    const gitignorePath = path.resolve(sourceDir, '../.gitignore');\r\n    const gitignorePatterns = fs.readFileSync(gitignorePath, 'utf8')\r\n      .split('\\n')\r\n      .filter((line) => line && !line.startsWith('#'))\r\n      .map((pattern) => new RegExp(pattern.replace(/\\*/g, '.*')));\r\n\r\n    const isIgnored = (file: string) => {\r\n      return gitignorePatterns.some((pattern) => pattern.test(file));\r\n    };\r\n\r\n    const list = fs.readdirSync(dir);\r\n    list.forEach((file) => {\r\n      file = path.join(dir, file);\r\n      if (isIgnored(file)) {\r\n        return;\r\n      }\r\n      const stat = fs.statSync(file);\r\n      if (stat && stat.isDirectory()) {\r\n        results = results.concat(readSourceFiles(file));\r\n      } else if (file.endsWith('.ts') || file.endsWith('.js')) {\r\n        results.push(file);\r\n      }\r\n    });\r\n    return results;\r\n  };\r\n\r\n  // Function to extract relevant information from the source code\r\n  const extractInfoFromSource = async (files: string[]): Promise<string> => {\r\n    let info = '';\r\n    files.forEach((file) => {\r\n      const content = fs.readFileSync(file, 'utf8');\r\n      info += `\\n\\n### ${file}\\n\\`\\`\\`typescript\\n${content}\\n\\`\\`\\`\\n`;\r\n    });\r\n    return info;\r\n  };\r\n\r\n  // Read all source files\r\n  const sourceFiles = readSourceFiles(sourceDir);\r\n\r\n  // Extract information from the source files\r\n  const extractedInfo = await extractInfoFromSource(sourceFiles);\r\n\r\n  const structure = await StructureDynamic({ extractedInfo }).run({});\r\n  let allSections = '';\r\n  // @ts-ignore\r\n  for (const rawCurrentSection of structure.Structure.Structure.split(',')) {\r\n    const currentSection = rawCurrentSection.trim()\r\n    const sectionContent = await SectionDynamic({ extractedInfo, structure, currentSection, allSections }).run({});\r\n    // @ts-ignore\r\n    allSections += sectionContent.SectionDynamic[currentSection];\r\n  }\r\n\r\n  const edit = await EditDynamic({ allSections }).run({});\r\n  // @ts-ignore\r\n  return edit.EditDynamic.Edit\r\n};\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\scripts\\summarize-pr.ts\n```typescript\n// import { Octokit } from 'octokit'\r\nimport * as process from 'node:process'\r\nimport { resolve } from 'node:path'\r\nimport { summarizePullRequest } from './orchistrations/SummarizePullRequests'\r\nimport { loadModel } from 'gpt4all'\r\n\r\n// const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN })\r\n\r\nprocess.env.DEFAULT_MODEL = 'Nous-Hermes-2-Mistral-7B-DPO.Q4_0.gguf'\r\nprocess.env.DEFAULT_ADAPTER = 'gpt4all'\r\n\r\nasync function main() {\r\n  console.log('Loading model...')\r\n  const model = await loadModel('Nous-Hermes-2-Mistral-7B-DPO.Q4_0.gguf', {\r\n    modelPath: resolve(process.cwd(), 'src/scripts/models'),\r\n  })\r\n  console.log('Creating chat session...')\r\n  const session = await model.createChatSession()\r\n\r\n  console.log('Summarizing pull request...')\r\n  const body = await summarizePullRequest(session)\r\n\r\n  // await octokit.rest.issues.createComment({\r\n  //   body,\r\n  //   repo: process.env.REPO_NAME,\r\n  //   owner: process.env.REPO_OWNER,\r\n  //   issue_number: process.env.PULL_NUMBER\r\n  // })\r\n  console.log(body)\r\n}\r\n\r\nmain().catch(console.error)\r\n\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\scripts\\update.js\n```typescript\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\skeleton\\config.ts\n```typescript\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\skeleton\\src\\index.ts\n```typescript\n// @ts-ignore\r\nimport { importPrompts, createDynamic, TOT } from \"duneai\";\r\n\r\nconst { HelloWorld: content } = importPrompts(\"./prompts.prompt\");\r\n\r\nconst runPrimeDynamic = async () => {\r\n\r\n  // Create a dynamic with 4 examples, asking each model to say hello.\r\n  const exampleModels = ['gpt-4o-mini', 'gpt-4o', 'gpt-4', 'gpt-3.5-turbo'];\r\n  const PrimeDynamic = createDynamic({\r\n    name: \"PrimeDynamic\",\r\n    kind: TOT,\r\n    prompts: exampleModels.map(model => ({ \r\n      name: `HelloWorld:${model}`, \r\n      content,\r\n      model\r\n    })),\r\n    log: true,\r\n  });\r\n\r\n  // Run the dynamic to run the examples.\r\n  const PrimeDynamicState = await PrimeDynamic.run();\r\n\r\n  // Log the resulting state.\r\n  // console.log({ PrimeDynamicState});\r\n};\r\n\r\nrunPrimeDynamic();\r\n\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\store\\index.ts\n```typescript\nimport { createStore } from \"zustand/vanilla\";\r\nimport { createPersistMiddleware } from \"../middleware\";\r\nimport type { DynamicState, NestedObjectType, SpiceType } from \"../modules/types\";\r\n\r\nexport const useStore = createStore<DynamicState>(\r\n  createPersistMiddleware(\"state.json\")((set: Function) => ({\r\n    state: {},\r\n    context: {},\r\n    setState: (dynamicName: string, key: string, value: any, spice?: SpiceType | boolean) =>\r\n      set((store: { state: Record<string, any>; shadowState?: Record<string, any> }) => {\r\n        const newState = {\r\n          ...store.state,\r\n          [dynamicName]: {\r\n            ...(store.state[dynamicName] || {}),\r\n            [key]: value,\r\n          },\r\n        };\r\n\r\n        if (spice !== false) {\r\n          return {\r\n            state: newState,\r\n            shadowState: {\r\n              ...store.shadowState,\r\n              [dynamicName]: {\r\n                ...(store.shadowState?.[dynamicName] || {}),\r\n                [key]: { \r\n                  completion: value, \r\n                  spice: spice ?? false,\r\n                },\r\n              },\r\n            },\r\n          };\r\n        }\r\n\r\n        return { state: newState };\r\n      }),\r\n    setContext: (context: NestedObjectType) =>\r\n      set(\r\n        (store: {\r\n          state: DynamicState[\"state\"];\r\n          context: DynamicState[\"context\"];\r\n        }) => ({\r\n          context: {\r\n            ...store.context,\r\n            ...context,\r\n          },\r\n        }),\r\n      ),\r\n    initializeState: (initialState: NestedObjectType) =>\r\n      set((store: DynamicState) => ({\r\n        state: {\r\n          ...store.state,\r\n          ...initialState,\r\n        },\r\n      })),\r\n  })),\r\n);\r\n\n```\n\n\n### Y:\\allusion\\DuneAI\\src\\utils\\index.ts\n```typescript\nimport tiktoken, { type TiktokenModel } from \"tiktoken\";\r\n\r\nexport const wait = (ms: number) => new Promise((r) => setTimeout(r, ms));\r\n\r\nexport const retryOperation = (\r\n  operation: any,\r\n  delay: number,\r\n  retries: number,\r\n) =>\r\n  new Promise((resolve, reject) => {\r\n    return operation()\r\n      .then(resolve)\r\n      .catch((reason: string) => {\r\n        if (retries > 0) {\r\n          return wait(delay)\r\n            .then(retryOperation.bind(null, operation, delay, retries - 1))\r\n            .then(resolve)\r\n            .catch(reject);\r\n        }\r\n        return reject(reason);\r\n      });\r\n  });\r\n\r\nexport const shuffle = (array: string[][]) => {\r\n  return array\r\n    .map((value) => ({ value, sort: Math.random() }))\r\n    .sort((a, b) => a.sort - b.sort)\r\n    .map(({ value }) => value);\r\n};\r\n\r\nexport const countTokens = (\r\n  content: string,\r\n  model: string,\r\n): { modelUsed: string; tokenCount: number } => {\r\n  let enc;\r\n  let tokenCount;\r\n  let modelUsed = model;\r\n  try {\r\n    enc = tiktoken.encoding_for_model(model as TiktokenModel);\r\n    tokenCount = enc.encode(content).length;\r\n  } catch {\r\n    modelUsed = \"gpt-4o\";\r\n    enc = tiktoken.encoding_for_model(modelUsed as TiktokenModel);\r\n    tokenCount = enc.encode(content).length;\r\n  } finally {\r\n    enc?.free();\r\n  }\r\n  return {\r\n    modelUsed,\r\n    tokenCount,\r\n  };\r\n};\r\n\n```\n"
  }
}