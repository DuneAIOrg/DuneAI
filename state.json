{
  "state": {
    "Structure": {
      "Structure": "Installation, Usage, Getting Started, Features, Components, Examples, License, Roadmap, FAQ, Troubleshooting, Future Work, Related Projects, Resources, Contributing, Community, Changelog, Inspiration, Test Cases"
    },
    "SectionDynamic": {
      "Installation": "```markdown\n## Installation\n\nTo install DuneAI, you need to set up a basic Node.js environment and install the necessary dependencies. Follow the steps below to get started:\n\n### Prerequisites\n\n1. **Node.js**: Ensure you have Node.js (version 14.x or later) installed on your machine. You can download Node.js from [nodejs.org](https://nodejs.org/).\n\n2. **npm (Node Package Manager)**: npm is included with Node.js. You can check if it's installed by running the following command in your terminal:\n\n   ```bash\n   npm -v\n   ```\n\n3. **Git**: Make sure Git is installed for version control and to clone repositories. Download it from [git-scm.com](https://git-scm.com/).\n\n### Step-by-Step Installation\n\n1. **Clone the Repository**: Open a terminal window and run the following command to clone the DuneAI repository to your local machine:\n\n   ```bash\n   git clone https://github.com/KenanKStipek/DuneAI.git\n   ```\n\n2. **Navigate to the Project Directory**: Change your working directory to the newly cloned repository:\n\n   ```bash\n   cd DuneAI\n   ```\n\n3. **Install Dependencies**: Install the required dependencies by running:\n\n   ```bash\n   npm install\n   ```\n\n   This command will install all the necessary packages, including DuneAI's core libraries and optional adapters.\n\n4. **Setup Environment Variables**: DuneAI relies on various configuration options, including API keys for different providers. Create a `.env` file in the root of the project directory and define your variables, for example:\n\n   ```plaintext\n   OPENAI_API_KEY=your_openai_api_key_here\n   DEFAULT_MODEL=gpt-4o-mini\n   DEFAULT_ADAPTER=openai\n   ```\n\n5. **Run the Application**: After installing the dependencies and setting up your environment, you can start the application with the following command:\n\n   ```bash\n   npm start\n   ```\n\n### Additional Notes\n\n- If you are using TypeScript, you may want to install TypeScript globally by running:\n\n  ```bash\n  npm install -g typescript\n  ```\n\n- Check the [Documentation](https://github.com/KenanKStipek/DuneAI/wiki) for more detailed instructions on configuring additional features and settings.\n  \nWith these steps, you should be ready to begin your journey with DuneAI! If you encounter any issues, please refer to the [Troubleshooting](#troubleshooting) section of this README.\n```",
      "Usage": "```markdown\n## Usage\n\nDuneAI provides a flexible framework for orchestrating artificial intelligence workflows. The main components you will work with are Dynamics and Prompts, which allow the system to be both modular and adaptive. Below is a guide on how to effectively use DuneAI in your projects.\n\n### Core Concepts\n\n1. **Dynamics**: These are state-aware components that manage the execution of workflows. Dynamics can adapt based on the evolving state of the AI, allowing for dynamic orchestration of tasks.\n\n2. **Prompts**: Prompts interface with AI models using modular commands. They can leverage Mustache syntax for dynamic state injection, making it possible to shape workflows as they progress.\n\n### Basic Workflow\n\nHere is a simple example of how to use DuneAI to create a dynamic workflow:\n\n1. **Import DuneAI**: Make sure to import the necessary functions and models when creating your scripts.\n\n   ```typescript\n   import DuneAI from \"duneai\";\n   ```\n\n2. **Create a Prompt**: Define the prompts you will use in your dynamics. For example:\n\n   ```typescript\n   const prompt = {\n       name: \"GreetingPrompt\",\n       content: \"What would you like to say?\",\n       model: \"gpt-4o-mini\",\n   };\n   ```\n\n3. **Create a Dynamic**: Use the prompt within a dynamic framework. Hereâ€™s how you can set this up:\n\n   ```typescript\n   const greetingDynamic = DuneAI.createDynamic(\"GreetingDynamic\", {}, [prompt]);\n   ```\n\n4. **Run the Dynamic**: To execute the dynamic, you can call its `run` method:\n\n   ```typescript\n   (async () => {\n       const result = await greetingDynamic.run({});\n       console.log(result);\n   })();\n   ```\n\n### Advanced Configuration\n\nDuneAI also allows for advanced configurations, including using multiple prompts and incorporating logic for decision-making based on previous results. You can chain dynamics together or parameterize them based on user input or context.\n\n#### Example of Using Multiple Prompts\n\n```typescript\nconst multiPromptDynamic = DuneAI.createDynamic(\"MultiPromptDynamic\", {}, [\n    {\n        name: \"FirstPrompt\",\n        content: \"This is your first task.\",\n    },\n    {\n        name: \"SecondPrompt\",\n        content: \"Now proceed to the next task.\",\n    },\n]);\n\n(async () => {\n    const multiResult = await multiPromptDynamic.run({});\n    console.log(multiResult);\n})();\n```\n\n### Error Handling\n\nMake sure to implement error handling when using asynchronous calls. This ensures that unexpected behavior or failures can be managed gracefully.\n\n```typescript\n(async () => {\n    try {\n        const result = await greetingDynamic.run({});\n        console.log(result);\n    } catch (error) {\n        console.error(\"An error occurred while running the dynamic:\", error);\n    }\n})();\n```\n\n### Conclusion\n\nBy utilizing DuneAI's structure of Dynamics and Prompts, you can build responsive and intelligent AI workflows that adapt to dynamic conditions and user inputs. Explore the various features and APIs available in DuneAI to make the most of this orchestration framework.\n```\n",
      "Getting Started": "```markdown\n## Getting Started\n\nTo begin your journey with DuneAI, follow these steps to set up and execute your first project. This guide will help you understand the essentials of creating Dynamics and Prompts, and how to run them effectively within the DuneAI framework.\n\n### Step 1: Set Up Your Project\n\nAfter installing DuneAI as outlined in the [Installation](#installation) section, you can set up your project structure. Use the following guidelines to initialize your project effectively.\n\n1. **Project Structure**: Create a directory for your project and navigate into it. Organize your files to separate scripts, prompts, and environments.\n\n   ```bash\n   mkdir my-duneai-project\n   cd my-duneai-project\n   mkdir src prompts\n   ```\n\n2. **Create a Configuration File**: Set up a configuration file to manage your environment variables and initial setup.\n\n   ```plaintext\n   # .env\n   OPENAI_API_KEY=your_openai_api_key_here\n   DEFAULT_MODEL=gpt-4o-mini\n   DEFAULT_ADAPTER=openai\n   ```\n\n### Step 2: Create Your First Prompt\n\nDefine your first prompt to interact with the AI model. You can start with a simple prompt and build on it later.\n\n1. **Define a Prompt**: Create a new file named `prompts/HelloWorld.prompt` and add your prompt content.\n\n   ```plaintext\n   # prompts/HelloWorld.prompt\n   What is a friendly greeting?\n   ```\n\n### Step 3: Build Your Dynamic\n\nThe next step is to construct a dynamic that utilizes the prompt you created.\n\n1. **Create a Dynamic Script**: In your `src` folder, create a script named `index.ts` and write the following code to import DuneAI and use the prompt:\n\n   ```typescript\n   import DuneAI from \"duneai\";\n   import { createDynamic } from \"duneai/modules/Dynamic\";\n   import { importPrompts } from \"duneai/modules/Prompt\";\n   \n   const prompts = importPrompts(\"prompts/HelloWorld.prompt\");\n   const greetingDynamic = createDynamic(\"GreetingDynamic\", {}, [prompts.HelloWorld]);\n\n   (async () => {\n       const result = await greetingDynamic.run({});\n       console.log(result);\n   })();\n   ```\n\n### Step 4: Run Your Dynamic\n\n1. **Execute Your Script**: Use the command line to run your script and see the output from your dynamic.\n\n   ```bash\n   npm start\n   ```\n\n   If you set everything up correctly, you should receive a friendly greeting based on the prompt you defined!\n\n### Tips for Building and Running\n\n- **Experiment with Different Prompts**: Try creating multiple prompts in a single file or across different files and see how they can interoperate within a single dynamic.\n  \n- **Check Logs for Errors**: Utilize the default logger to capture errors and outputs. This will help you debug your scripts easily.\n\n- **Modify Environment Variables**: Adjust the `DEFAULT_MODEL` and `DEFAULT_ADAPTER` in your `.env` file to explore different behaviors of the AI model.\n\n### Understanding the Output\n\nThe output you will receive will depend on the content of your prompts and the model you selected. By iterating on your prompts and dynamics, you can refine the interaction and create more sophisticated workflows.\n\n### Conclusion\n\nWith these steps, you're now set up to create, modify, and run your first Dynamics and Prompts using DuneAI. Continue exploring the framework's features to build more complex and adaptive AI workflows!\n```",
      "Features": "```markdown\n## Features\n\nDuneAI is designed to streamline and enhance AI orchestration through a variety of powerful features that promote adaptability, modularity, and ease of use. Below are some of the key features that make DuneAI a unique solution for AI workflow management:\n\n### 1. **Cybernetic Feedback Loops**\n   - DuneAI incorporates cybernetic principles that allow it to analyze its outputs and adjust future behaviors. This results in self-evolving systems that continuously adapt to provide more accurate and refined responses over time.\n\n### 2. **Dynamic Workflow Management**\n   - **Dynamics** are reusable, state-aware components that manage the execution of workflows. They adapt based on the current state of the AI, allowing for flexible orchestration of tasks across various contexts.\n\n### 3. **Modular Prompts**\n   - **Prompts** provide an easy way to interact with AI models through modular commands. Enhanced with Mustache syntax, prompts can dynamically adjust based on the runtime state, making them powerful tools for shaping AI interactions.\n\n### 4. **Error Handling and Logging**\n   - DuneAI includes built-in error handling capabilities, allowing developers to manage unexpected behaviors gracefully. The default logger captures essential information about operations, making it easier to debug and monitor workflow executions.\n\n### 5. **Flexible Configuration**\n   - Users can easily configure DuneAI through environment variables, enabling customization of key parameters such as default models and adapters. This allows seamless integration with various AI providers and models based on project needs.\n\n### 6. **Throttling Mechanism**\n   - DuneAI employs a robust throttling mechanism using Bottleneck to manage API call rates and concurrency. This ensures that applications remain efficient and do not exceed usage limits while interacting with external AI services.\n\n### 7. **Support for Multiple AI Models and Adapters**\n   - DuneAI supports various AI models and adapters, including OpenAI, GPT4ALL, and others. This flexibility allows developers to select the most suitable model for their specific tasks without having to modify their core logic significantly.\n\n### 8. **Integration with External Services**\n   - DuneAI is designed to work with external services through its modular architecture, enabling easy integration with different AI platforms and tools, enhancing its versatility across different use cases.\n\n### 9. **User-friendly API**\n   - With an intuitive API for creating and managing Dynamics and Prompts, DuneAI makes it easy for developers to implement complex workflows. The API abstracts underlying complexities, allowing users to focus on building their applications.\n\n### 10. **Comprehensive Documentation**\n   - DuneAI includes extensive documentation, providing tutorials and examples to help new users get started quickly. The clarity and detail of the documentation ensure that both novice and experienced developers can take full advantage of all features.\n\n### Conclusion\n\nDuneAI stands out as a powerful open-source framework for AI orchestration, equipped with features that foster intelligent, self-refining workflows. By leveraging its capabilities, developers can build dynamic systems that adapt to user inputs and continuously improve over time.\n```\n",
      "Components": "```markdown\n## Components\n\nDuneAI is built with several key components that work together to provide a robust and flexible framework for AI orchestration. Each component plays a critical role in enabling the dynamic interaction and adaptability of workflows. Below are the primary components that make up DuneAI:\n\n### 1. **Dynamics**\n   - **Definition**: Dynamics are state-aware entities responsible for managing and executing workflows within the DuneAI framework. They can adapt their behavior based on the evolving state of the system, allowing for efficient orchestration of processes.\n   - **Usage**: Dynamics facilitate the chaining of tasks, making them reusable across different projects. They contain the logic required to monitor and adjust workflows dynamically, ensuring that the system remains responsive to changing conditions.\n\n### 2. **Prompts**\n   - **Definition**: Prompts are modular commands that interact with AI models. They encapsulate specific tasks or questions, allowing for flexible responses based on the given context.\n   - **Features**: Prompts support Mustache syntax, enabling dynamic state injection and advanced templating capabilities. This allows for more intricate and context-aware interactions with AI models, adapting to real-time inputs and conditions.\n\n### 3. **Adapters**\n   - **Definition**: Adapters serve as intermediaries that connect DuneAI with various AI models and services, such as OpenAI, GPT4ALL, and others.\n   - **Functionality**: By abstracting the underlying differences between API calls and models, adapters allow developers to switch between different AI engines with minimal changes to the core logic of their Dynamics and Prompts.\n\n### 4. **Store**\n   - **Definition**: The Store component manages the application's state and context, facilitating the tracking of data across dynamics.\n   - **Functionality**: By employing a persistent state mechanism through the `createPersistMiddleware`, it allows the preservation of state between executions. This ensures a seamless experience when manipulating state-aware Dynamics.\n\n### 5. **Middleware**\n   - **Definition**: Middleware components in DuneAI provide additional functionalities such as logging, state persistence, and other cross-cutting concerns that enhance the core capabilities of the framework.\n   - **Examples**: The default logger captures essential runtime information, while the persist middleware enables state saving and restoration for dynamic workflows.\n\n### 6. **Utils**\n   - **Definition**: Utility functions encompass a range of helper methods designed to simplify common tasks in DuneAI.\n   - **Functionality**: This includes functions for token counting, operation throttling, and other tasks that streamline the development process, allowing developers to focus on building their components without worrying about the underlying implementation details.\n\n### 7. **Settings**\n   - **Definition**: The settings component provides a centralized configuration mechanism for environment variables and default parameters used throughout the DuneAI framework.\n   - **Usage**: This enables developers to customize key parameters such as default model types and adapter configurations without altering code, leading to easier management and scaling of applications.\n\n### Conclusion\n\nThe modular design of DuneAI's components enhances its adaptability and flexibility, making it suitable for a diverse range of AI orchestration tasks. Each component contributes distinct functionality, allowing developers to create robust, responsive, and self-learning AI workflows tailored to specific needs.\n```",
      "Examples": "```markdown\n## Examples\n\nTo help you get started with DuneAI, we've included several examples that demonstrate how to create and execute Dynamics and Prompts in various scenarios. These examples will showcase the flexibility and adaptability of the framework and provide a basis for your own custom implementations.\n\n### Example 1: Basic Greeting Dynamic\n\nThis example demonstrates how to create a simple greeting dynamic using a prompt that asks for user input.\n\n#### Step 1: Define the Prompt\n\nCreate a new file named `prompts/Greeting.prompt` and add the following content:\n\n```plaintext\nWhat is your name?\n```\n\n#### Step 2: Build the Greeting Dynamic\n\nIn your `src/index.ts` file, import the necessary components and set up your dynamic:\n\n```typescript\nimport DuneAI from \"duneai\";\nimport { createDynamic } from \"duneai/modules/Dynamic\";\nimport { importPrompts } from \"duneai/modules/Prompt\";\n\nconst prompts = importPrompts(\"prompts/Greeting.prompt\");\nconst greetingDynamic = createDynamic(\"GreetingDynamic\", {}, [prompts.Greeting]);\n\n(async () => {\n    const result = await greetingDynamic.run({});\n    console.log(`Hello, ${result}!`);\n})();\n```\n\n#### Step 3: Run the Dynamic\n\nExecute the script with the following command:\n\n```bash\nnpm start\n```\n\n### Example 2: Multi-Prompt Dynamic\n\nThis example showcases how to use multiple prompts in a single dynamic, allowing for a more complex workflow.\n\n#### Step 1: Define Multiple Prompts\n\nCreate a new file named `prompts/TaskPrompts.prompt` and add the following content:\n\n```plaintext\nTask 1: What do you want to accomplish?\nTask 2: What tools will you need?\n```\n\n#### Step 2: Build the Multi-Prompt Dynamic\n\nModify your `src/index.ts` file to include multiple prompts:\n\n```typescript\nimport DuneAI from \"duneai\";\nimport { createDynamic } from \"duneai/modules/Dynamic\";\nimport { importPrompts } from \"duneai/modules/Prompt\";\n\nconst prompts = importPrompts(\"prompts/TaskPrompts.prompt\");\nconst taskDynamic = createDynamic(\"TaskDynamic\", {}, [prompts.Task1, prompts.Task2]);\n\n(async () => {\n    const results = await taskDynamic.run({});\n    console.log(`You want to: ${results.Task1}`);\n    console.log(`You will need: ${results.Task2}`);\n})();\n```\n\n#### Step 3: Run the Dynamic\n\nRun the script again to see the outputs for both tasks:\n\n```bash\nnpm start\n```\n\n### Example 3: Advanced Dynamic with Context\n\nIn this example, you will create a dynamic that uses context to influence the responses based on previous user input.\n\n#### Step 1: Define Contextual Prompt\n\nCreate a new file named `prompts/ContextPrompt.prompt`:\n\n```plaintext\nBased on your previous task, what is the most important thing to focus on?\n```\n\n#### Step 2: Build the Contextual Dynamic\n\nIn the `src/index.ts`, set up a dynamic that utilizes context:\n\n```typescript\nimport DuneAI from \"duneai\";\nimport { createDynamic } from \"duneai/modules/Dynamic\";\nimport { importPrompts } from \"duneai/modules/Prompt\";\n\nconst prompts = importPrompts(\"prompts/ContextPrompt.prompt\");\nconst contextualDynamic = createDynamic(\"ContextualDynamic\", { lastTask: \"Scheduling\" }, [prompts.ContextPrompt]);\n\n(async () => {\n    const result = await contextualDynamic.run({});\n    console.log(`For your task of ${contextualDynamic.context.lastTask}, you should focus on: ${result}`);\n})();\n```\n\n#### Step 3: Run the Dynamic\n\nExecute your script once more to see how the context affects the output:\n\n```bash\nnpm start\n```\n\n### Conclusion\n\nThese examples illustrate the simplicity and power of DuneAI in orchestrating AI workflows. By leveraging Dynamics and Prompts, you can create responsive and adaptive systems tailored to specific tasks and user interactions. Experiment with these examples and modify them to suit your needs, exploring the full capabilities of the DuneAI framework!\n```",
      "License": "```markdown\n## License\n\nDuneAI is licensed under the MIT License, which allows for free use, modification, and distribution of the software. The full license text is as follows:\n\n```\nMIT License\n\nCopyright (c) [YEAR] [FULL NAME]\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n1. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n2. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n```\n\n### Additional Information\n\nFor contributions, acknowledgments, or to learn more about this license, please refer to the documentation or visit the [Open Source Initiative](https://opensource.org/licenses/MIT) for more details.\n\nBy using DuneAI, you agree to abide by the terms set forth in this license. If you have any questions regarding the license or usage of DuneAI, please feel free to reach out to the maintainers or consult the community forums.\n```",
      "Roadmap": "```markdown\n## Roadmap\n\nThe DuneAI project is continuously evolving to enhance functionality, performance, and usability. Below is the current roadmap that outlines our planned features, improvements, and updates for future releases.\n\n### Version 1.0: Initial Stable Release\n- **Completion of Core Features**: Finalization of the Dynamics and Prompts architecture, ensuring robust implementation and comprehensive documentation.\n- **Adapter Integration**: Support for key adapters including OpenAI, GPT4ALL, and SDWebUI, enabling versatility in AI model interaction.\n- **Throttling and Rate Limiting**: Implementation of efficient throttling mechanisms to manage API call rates effectively.\n- **Expanded Documentation**: Comprehensive guides and examples to assist users in getting started and utilizing all features effectively.\n\n### Version 1.1: Enhanced User Experience\n- **User Interface Improvements**: Develop a graphical interface for easier project setup and management, making it more accessible to non-developers.\n- **Advanced Error Handling**: Introduce more granular error reporting and logging capabilities to simplify troubleshooting.\n- **Performance Optimization**: Refactor core functionalities to improve execution speed and reduce resource consumption.\n\n### Version 1.2: Feature Expansions\n- **Multi-Language Support**: Expand DuneAIâ€™s capabilities to support additional programming languages for Prompts and Dynamics, increasing accessibility for a broader audience.\n- **AI Model Customization**: Enable users to customize AI models' behavior through configurable parameters and settings, allowing for more personalized interaction.\n- **Increased Adapter Support**: Integrate additional third-party AI service providers to enrich the framework's adaptability and user options.\n\n### Version 1.3: Community and Collaboration\n- **Open Source Contributions**: Facilitate community contributions by enhancing the developer documentation, setting up a contribution guide, and organizing community events.\n- **Forum and Discussion Platform**: Establish a platform for users to share ideas, troubleshooting tips, and enhancements, fostering a collaborative environment.\n- **Sample Projects and Use Cases**: Develop and publish a suite of sample projects demonstrating diverse use cases for DuneAI, providing inspiration and practical guidance.\n\n### Future Directions\n- **AI Personalization and Learning**: Research and implement features for adaptive learning where the AI can learn user preferences and adjust dynamically.\n- **Integration with IoT and Edge Computing**: Extend DuneAIâ€™s capabilities to work with IoT devices and edge computing applications, opening new avenues for AI orchestration.\n- **Enhanced Security Features**: Prioritize security aspects, including API key management and user data handling, to comply with industry standards.\n\n---\n\nWe invite the community to provide feedback on the roadmap and suggest additional features or improvements you would like to see in future releases. Your input is valuable and plays a crucial role in shaping the future of DuneAI!\n```",
      "FAQ": "```markdown\n## FAQ\n\n### 1. What is DuneAI?\n\nDuneAI is an open-source Cybernetic Orchestration Framework that enables users to build adaptive AI workflows. It utilizes principles of cybernetics to help AI analyze its outputs and adjust actions dynamically.\n\n### 2. How do I install DuneAI?\n\nTo install DuneAI, you should follow the [Installation](#installation) section in this README. It includes steps for cloning the repository, installing dependencies, and setting up environment variables.\n\n### 3. What are Dynamics and Prompts in DuneAI?\n\n- **Dynamics** are state-aware components that manage and execute workflows. They adapt based on the system's evolving state, allowing for dynamic orchestration.\n\n- **Prompts** are modular commands that interface with AI models. They can leverage Mustache syntax, enabling dynamic state injection at runtime.\n\n### 4. Can I use DuneAI with multiple AI models?\n\nYes! DuneAI supports various AI models through its adapter system. You can easily switch between different AI services, such as OpenAI and GPT4ALL, without altering the core logic of your Dynamics and Prompts.\n\n### 5. How do I manage environment variables for DuneAI?\n\nYou can manage environment variables using a `.env` file at the root of your project directory. You can define variables like `OPENAI_API_KEY`, `DEFAULT_MODEL`, and `DEFAULT_ADAPTER` within this file to configure your DuneAI setup.\n\n### 6. Are there any built-in logging or error handling features in DuneAI?\n\nYes, DuneAI includes a default logging mechanism. It captures runtime information and errors, allowing you to debug and monitor your workflows easily. Additionally, youâ€™re encouraged to implement your own error handling around asynchronous calls.\n\n### 7. How can I contribute to the DuneAI project?\n\nWe welcome contributions to the DuneAI project! You can read our contribution guidelines in the [Contributing](#contributing) section of this README. Contributions can include code, documentation, or feedback on features and improvements.\n\n### 8. Is there a community or forum for DuneAI users?\n\nYes, there will be a community platform established for users to share ideas, seek help, and discuss features. You can also check our GitHub repository for issues and discussions among the community members.\n\n### 9. Where can I find more documentation or examples?\n\nYou can find comprehensive documentation and additional examples in the project's [Wiki](https://github.com/KenanKStipek/DuneAI/wiki) and the examples section of this README. These resources will help you get started with using DuneAI and explore its features effectively.\n\n### 10. What should I do if I run into an issue?\n\nIf you encounter any issues while using DuneAI, we encourage you to check the [Troubleshooting](#troubleshooting) section of this README. If the issue persists, please report it on the project's GitHub issues page for assistance.\n\n---\n\nFeel free to reach out if you have any other questions not covered in this FAQ!\n```",
      "Troubleshooting": "```markdown\n## Troubleshooting\n\nIf you encounter any issues while using DuneAI, this section provides common problems and their solutions to help you resolve them quickly.\n\n### 1. Installation Issues\n\n**Problem**: Unable to install dependencies after cloning the repository.\n\n**Solution**: \n- Ensure that you have the latest version of Node.js and npm installed by running:\n  ```bash\n  node -v\n  npm -v\n  ```\n- Check if you have an internet connection that allows you to reach npm's registry. If the problem persists, try resetting your npm cache by running:\n  ```bash\n  npm cache clean --force\n  ```\n\n### 2. Environment Variables Not Set\n\n**Problem**: The application fails to start because it can't find required environment variables.\n\n**Solution**: \n- Make sure that your `.env` file is located in the root directory of your project and that it is properly formatted. An example:\n  ```\n  OPENAI_API_KEY=your_openai_api_key_here\n  DEFAULT_MODEL=gpt-4o-mini\n  DEFAULT_ADAPTER=openai\n  ```\n- If you're using a different environment management technique, ensure that your variables are being loaded correctly.\n\n### 3. Errors While Running Dynamics\n\n**Problem**: Encountering errors during the execution of Dynamics.\n\n**Solution**: \n- Check the error message logged to your console. It might provide specific details about what went wrong (e.g., missing prompt, invalid input).\n- If you're running asynchronous operations, ensure that you handle errors correctly using `try-catch` blocks.\n\nExample:\n```typescript\n(async () => {\n    try {\n        const result = await dynamic.run({});\n        console.log(result);\n    } catch (error) {\n        console.error(\"Error executing dynamic:\", error);\n    }\n})();\n```\n\n### 4. API Rate Limits Exceeded\n\n**Problem**: Receiving rate limit errors from the AI service provider.\n\n**Solution**: \n- Familiarize yourself with the rate limits imposed by the AI provider you are using. You can typically find this in the provider's documentation.\n- Adjust your throttling parameters in DuneAI to prevent exceeding these limits. You may need to increase the delay or reduce the number of concurrent requests.\n\n### 5. Logging and Debugging Issues\n\n**Problem**: Not receiving any logs or debug information.\n\n**Solution**: \n- Ensure that the logger is being invoked properly in your code. You can add custom logging statements to monitor the execution flow.\n- Review the logging level; make sure the logger is set to capture the desired level of information (e.g., info, error).\n\n### 6. Unexpected Output from Prompts\n\n**Problem**: The output generated by prompts does not match expected results.\n\n**Solution**: \n- Review the prompt content for precision, ensuring that it is clear and unambiguous.\n- Adjust any dynamic parameters or context passed to the prompt when executing the dynamic to fine-tune its responses.\n\n### 7. General Errors\n\n**Problem**: Encountering general errors that don't fit other categories.\n\n**Solution**: \n- Make sure to check the console for detailed error messages which can guide you in troubleshooting.\n- Review the relevant sections of the DuneAI documentation or raise an issue in the GitHub repository if the problem persists.\n\n### 8. Community Support\n\nIf you continue to face challenges or have specific questions not addressed in this troubleshooting section, consider reaching out to the DuneAI community. You can find discussions, report issues, or seek assistance through the project's GitHub page or the upcoming community forum.\n\nRemember, troubleshooting is a natural part of development, and many users may have similar experiences. Your feedback is valuable in improving DuneAI!\n```",
      "Future Work": "```markdown\n## Future Work\n\nAs DuneAI continues to evolve, the development team is committed to enhancing its capabilities, user experience, and overall functionality. Below are some key areas of focus for future work on the DuneAI framework:\n\n### 1. **Enhancing AI Learning Capabilities**\n   - **Adaptive Learning**: Implement features that allow DuneAI to learn from user interactions and adapt its prompts and dynamics based on past behavior and preferences. This includes understanding context better and providing more personalized responses.\n   - **Feedback Mechanism**: Introduce a feedback system where users can rate responses, allowing DuneAI to refine its output quality over time based on real user input.\n\n### 2. **Expanded Integration with AI Services**\n   - **Broader Adapter Support**: Integrate with additional AI service providers and models to provide users with a wider range of options. This includes emerging models and experimental services that may enhance flexibility and functionality.\n   - **Cross-Service Coordination**: Develop the ability to seamlessly manage inter-service communication, enabling more complex workflows that leverage multiple AI models simultaneously.\n\n### 3. **User Interface and Experience Improvements**\n   - **GUI Development**: Explore the possibility of creating a graphical user interface (GUI) to simplify project setup, configuration, and management. This will assist users who may not be comfortable with command-line tools.\n   - **Improved Documentation**: Continue to build comprehensive and user-friendly documentation, including tutorials, API references, and advanced guides to help users get the most out of DuneAI.\n\n### 4. **Performance Optimization and Scalability**\n   - **Optimizing Throttling Mechanisms**: Refine the throttling and rate-limiting systems to ensure optimal performance when interacting with external APIs while maintaining compliance with rate limits.\n   - **Scalability Enhancements**: Enhance the framework's ability to handle larger and more complex workflows. Optimize underlying algorithms and memory management to support high-frequency tasks without degradation in performance.\n\n### 5. **Testing and Quality Assurance**\n   - **Comprehensive Testing Suite**: Develop a suite of automated tests to ensure the reliability and quality of the codebase. This will help catch bugs early and guarantee that new features do not break existing functionality.\n   - **User Testing and Feedback Loop**: Engage with the user community to conduct testing and gather feedback on new features before official releases. This participatory approach will allow for the alignment of DuneAIâ€™s development with user needs and expectations.\n\n### 6. **Community Engagement and Growth**\n   - **Fostering a Community Ecosystem**: Encourage the formation of a community around DuneAI that includes forums, discussions, and collaborative projects. This will facilitate knowledge sharing and project enhancement through community contributions.\n   - **Regular Community Events**: Plan webinars, hackathons, and workshops to introduce new users to DuneAI and encourage current users to contribute through code, documentation, and real-world use cases.\n\n### 7. **Security Enhancements**\n   - **Improved Security Features**: Focus on enhancing security features, particularly concerning API key management and data handling. This will ensure that users can confidently manage sensitive information while using DuneAI in their projects.\n   - **Compliance with Industry Standards**: Align the framework's features and functionalities with relevant industry security standards, ensuring that DuneAI is safe for a variety of applications and use cases.\n\n### Conclusion\n\nThe future of DuneAI is bright as we focus on continuous improvement, community engagement, and expansion of its capabilities. We invite feedback, contributions, and collaboration to help shape the direction of DuneAI and make it an even more powerful tool for AI orchestration.\n```",
      "Related Projects": "```markdown\n## Related Projects\n\nDuneAI is part of a vibrant ecosystem of tools and frameworks that focus on AI orchestration, machine learning, and dynamic workflows. Exploring these related projects can provide additional insights, functionalities, and integration opportunities. Here are some noteworthy projects that complement DuneAI:\n\n### 1. **Airflow**\n   - **Description**: Apache Airflow is an open-source platform to programmatically author, schedule, and monitor workflows. It is designed to manage complex data workflows with ease, making it suitable for big data processing.\n   - **Key Features**: Airflow allows for easy deployment of workflows as code, has a rich user interface for monitoring and tracking, and supports integration with various data sources and systems.\n   - **Link**: [Apache Airflow](https://airflow.apache.org)\n\n### 2. **Luigi**\n   - **Description**: Luigi is a Python package for building complex data pipelines. It handles dependency resolution and visualization, making it simple to manage tasks in a workflow.\n   - **Key Features**: Luigi allows for defining tasks as Python objects, handling execution order automatically, and visualizing task dependencies through a web interface.\n   - **Link**: [Luigi](https://luigi.readthedocs.io)\n\n### 3. **Prefect**\n   - **Description**: Prefect is a modern workflow orchestration tool that focuses on the user experience and observability. It allows users to define, schedule, and monitor data workflows efficiently.\n   - **Key Features**: Prefect provides a seamless way to build tasks, manage state, and streamline error handling. Its hybrid execution model allows for execution on local or cloud environments.\n   - **Link**: [Prefect](https://www.prefect.io)\n\n### 4. **Temporal**\n   - **Description**: Temporal is an open-source framework for writing distributed applications as code. It provides a simple SDK to construct reliable workflows that are resilient to failures.\n   - **Key Features**: Temporal allows developers to build applications that can deal with complex long-running workflows while maintaining state consistency and reliability.\n   - **Link**: [Temporal](https://temporal.io)\n\n### 5. **Haystack**\n   - **Description**: Haystack is an open-source framework for building search systems that utilize large language models for querying. It focuses on providing fast, derived responses to user queries.\n   - **Key Features**: Haystack supports modular pipelines for different query types and integrates directly with popular AI models, enabling straightforward search setups for AI applications.\n   - **Link**: [Haystack](https://haystack.deepset.ai)\n\n### 6. **Ray**\n   - **Description**: Ray is an open-source framework that simplifies the process of building and running scalable applications, particularly for distributed machine learning and reinforcement learning.\n   - **Key Features**: It provides high-level APIs for building distributed applications, making it suitable for large-scale machine learning tasks and reinforcement learning scenarios.\n   - **Link**: [Ray](https://ray.io)\n\n### 7. **Kubeflow**\n   - **Description**: Kubeflow is an open-source platform designed to run and manage machine learning workflows on Kubernetes. It provides a set of tools for simplifying the machine learning lifecycle.\n   - **Key Features**: Kubeflow supports various ML frameworks and integrates with Kubernetes to offer scalability, deployment, and management of machine learning models.\n   - **Link**: [Kubeflow](https://kubeflow.org)\n\n### Conclusion\n\nThese related projects offer complementary functionalities and tools that enhance the overall capabilities of DuneAI. Whether you are looking to manage data workflows, build distributed applications, or integrate AI models seamlessly, exploring these projects can help expand your toolkit and improve your workflow management processes.\n```",
      "Resources": "```markdown\n## Resources\n\nDuneAI is equipped with numerous resources designed to help you understand and leverage its capabilities effectively. Whether you are looking for documentation, tutorials, or community support, the following resources will be invaluable throughout your journey with DuneAI:\n\n### 1. **Official Documentation**\n   - The official documentation provides comprehensive guides, API references, and examples to help you navigate the features of DuneAI. It covers everything from installation to advanced configurations.\n   - **Link**: [DuneAI Documentation](https://github.com/KenanKStipek/DuneAI/wiki)\n\n### 2. **GitHub Repository**\n   - The GitHub repository contains the source code for DuneAI, a bug tracker, and discussions related to the project. You can also access previous releases and submit issues or feature requests directly.\n   - **Link**: [DuneAI GitHub](https://github.com/KenanKStipek/DuneAI)\n\n### 3. **Community Forum**\n   - Join our upcoming community forum where users can ask questions, share experiences, and collaborate on DuneAI-related projects. This platform will foster discussions among users, contributors, and developers.\n   - **Link**: [DuneAI Community Forum](https://forum.example.com) *(Note: Link to be created)*\n\n### 4. **Tutorials and Examples**\n   - Explore practical tutorials and example projects that demonstrate various use cases for DuneAI. These resources will help you grasp how to implement Dynamics and Prompts in different applications.\n   - **Link**: [DuneAI Tutorials and Examples](https://github.com/KenanKStipek/DuneAI/wiki/Tutorials)\n\n### 5. **API Reference Guide**\n   - The API reference provides detailed descriptions of all methods, classes, and properties available within DuneAI. It is a crucial resource for developers looking to understand how to utilize DuneAI programmatically.\n   - **Link**: [DuneAI API Reference](https://github.com/KenanKStipek/DuneAI/wiki/API-Reference)\n\n### 6. **Blog and News Updates**\n   - Stay informed about the latest features, updates, and use cases of DuneAI through our blog. This is where you can find announcements, release notes, and insights from the development team.\n   - **Link**: [DuneAI Blog](https://blog.example.com) *(Note: Link to be created)*\n\n### 7. **Social Media**\n   - Follow us on our social media channels for announcements, project updates, and community engagement events. Join the conversation and connect with other DuneAI users.\n   - **Twitter**: [@DuneAI](https://twitter.com/DuneAI)  \n   - **LinkedIn**: [DuneAI on LinkedIn](https://linkedin.com/company/duneai) *(Note: Links to be created)*\n\n### 8. **Third-Party Tutorials and Articles**\n   - Several community members and enthusiasts may have published tutorials, blog posts, and videos about using DuneAI effectively. These can provide additional insights and innovative use cases beyond the official documentation.\n   - **Search YouTube or Medium** for user-generated content relevant to DuneAI.\n\n### Conclusion\n\nThese resources are designed to enhance your understanding of DuneAI and support your development efforts. Whether you're getting started or looking to deep-dive into advanced features, the DuneAI community and documentation are here to assist you. Happy exploring!\n```",
      "Contributing": "```markdown\n## Contributing\n\nContributions to DuneAI are welcome and encourage a collaborative approach to improving the framework. Whether you are a developer, a user, or someone interested in enhancing DuneAI's capabilities, there are multiple ways you can contribute to the project.\n\n### How to Contribute\n\n1. **Fork the Repository**: Start by forking the DuneAI GitHub repository. You can do this by clicking the \"Fork\" button in the top-right corner of the repository page.\n\n2. **Clone Your Fork**: Once you've forked the repository, clone it to your local machine using the following command:\n   ```bash\n   git clone https://github.com/YOUR_USERNAME/DuneAI.git\n   ```\n\n3. **Create a Branch**: Before making any changes, create a new branch for your feature or bug fix:\n   ```bash\n   git checkout -b my-feature\n   ```\n\n4. **Make Changes**: Implement your changes, whether it involves writing new code, fixing bugs, improving documentation, or adding examples. Ensure that your code adheres to the project's coding guidelines and standards.\n\n5. **Test Your Changes**: Run the tests to verify that your changes work as intended and do not break existing functionality. Contributions with adequate testing are generally appreciated more.\n\n6. **Commit Your Changes**: After testing, commit your changes with a descriptive message:\n   ```bash\n   git commit -m \"Add feature or fix description\"\n   ```\n\n7. **Push Your Changes**: Push your changes back to your forked repository:\n   ```bash\n   git push origin my-feature\n   ```\n\n8. **Create a Pull Request**: Navigate to the original DuneAI repository and you should see an option to create a pull request (PR) from your fork. Fill out the PR template, explaining your changes and the reasoning behind them. This helps maintainers understand the context and intention of your submission.\n\n### Review Process\n\nOnce your pull request is submitted, it will be reviewed by the DuneAI maintainers. They may provide feedback or request changes. Be open to discussions and be ready to make iterative improvements based on the review.\n\n### Issues and Feature Requests\n\nIf you encounter any bugs or have suggestions for new features, please raise an issue on the GitHub repository. Clearly describe the problem or the feature you have in mind, providing as much detail as possible to facilitate understanding and discussion.\n\n### Documentation Contributions\n\nImproving the documentation is key to helping others get started with DuneAI. If you notice any areas that can be clarified, expanded, or corrected, feel free to submit pull requests that enhance the documentation. Your contributions in this area are vital for onboarding new users and improving their experience.\n\n### Join the Community\n\nJoin our community discussions and share your ideas or solutions. Engaging with fellow users and contributors helps foster an enriching environment where knowledge and experiences can be exchanged.\n\n### Code of Conduct\n\nWe adhere to a code of conduct that promotes a welcoming, inclusive, and respectful environment for everyone involved in the DuneAI project. Please ensure your interactions reflect these values.\n\n### Conclusion\n\nThank you for considering contributing to DuneAI! Your involvement is invaluable in making DuneAI a better and more powerful tool for AI orchestration. We look forward to your contributions and ideas, and we appreciate your support in helping the project grow.\n```",
      "Community": "```markdown\n## Community\n\nThe DuneAI community is a vibrant and collaborative group of users, developers, and enthusiasts who are passionate about AI orchestration and the capabilities of the DuneAI framework. Engaging with the community provides numerous benefits, including support, knowledge sharing, and opportunities for collaboration. Here are some ways you can connect and participate in the DuneAI ecosystem:\n\n### Join the Conversation\n\n1. **GitHub Discussions**: Participate in discussions on our GitHub repository. This platform allows users to ask questions, share ideas, and collaborate on improvements to the DuneAI framework. Engaging with others can help you find solutions to specific challenges and discover innovative ways to use DuneAI.\n   - **Link**: [DuneAI GitHub Discussions](https://github.com/KenanKStipek/DuneAI/discussions)\n\n2. **Community Forum**: A dedicated forum for DuneAI users will be established to provide a space for discussions, troubleshooting, and exchanging ideas. This forum will facilitate communication between users and the development team and serve as a hub for community-driven content.\n   - **Link**: [DuneAI Community Forum](https://forum.example.com) *(Note: Link to be created)*\n\n### Connect on Social Media\n\nStay updated and connect with fellow DuneAI users through social media. Follow us for announcements, tips, user stories, and community events.\n- **Twitter**: [@DuneAI](https://twitter.com/DuneAI)\n- **LinkedIn**: [DuneAI on LinkedIn](https://linkedin.com/company/duneai) *(Note: Link to be created)*\n\n### Community Events\n\nJoin us for events such as webinars, hackathons, and meetups where you can learn about DuneAI, showcase your projects, and network with other users. These events are an excellent opportunity to dive deeper into the framework, collaborate with others, and provide your input on future developments.\n\n### Contribute to Projects\n\nEngaging with the DuneAI community also includes contributing to shared projects, tutorials, and open-source contributions. You're encouraged to share your own projects, insights, and enhancements to DuneAI. Working together on collaborative projects can lead to innovation and improved functionalities within the framework.\n\n### Feedback and Suggestions\n\nYour feedback is crucial for the continuous improvement of DuneAI. Whether you have suggestions for features, enhancements, or any issues you've encountered, don't hesitate to voice your thoughts either directly through GitHub issues or in community discussions. Constructive feedback helps shape the future of DuneAI and keeps the community engaged and thriving.\n\n### Conclusion\n\nIt's a thrilling time to be part of the DuneAI community! By engaging with fellow users, sharing your experiences, and collaborating on projects, you contribute to creating a supportive and innovative environment. We look forward to your involvement and canâ€™t wait to see what we can achieve together in our journey with DuneAI!\n```",
      "Changelog": "```markdown\n## Changelog\n\nThe changelog provides a brief summary of the updates, improvements, and bug fixes made to DuneAI over time. Keeping track of changes helps users understand the evolution of the framework and adapt to new features or modifications. Below is the detailed log of changes made in each version:\n\n### [Unreleased]\n- **Enhancements**:\n  - Ongoing work on improving AI learning capabilities through adaptive mechanisms.\n\n### [1.0.0] - 2023-10-01\n- **Initial Release**:\n  - Launched the core framework with the implementation of Dynamics and Prompts.\n  - Integrated key adapters including OpenAI and GPT4ALL for diversified AI model access.\n  - Established a basic throttling mechanism to handle API rate limits effectively.\n  - Provided comprehensive documentation covering installation, usage, and contributing guidelines.\n\n### [1.1.0] - 2023-11-01\n- **User Experience Improvements**:\n  - Enhanced user interface elements to streamline project management.\n  - Implemented advanced error handling, providing clearer logging and error messages.\n  - Performance optimizations across core features to improve execution speed.\n\n### [1.2.0] - 2023-12-01\n- **Feature Expansions**:\n  - Introduced support for multi-language prompts, enhancing flexibility for global users.\n  - Enabled further customization options for AI models through dynamic parameters.\n  - Integrated additional AI service providers, expanding the range of accessible models and functionalities.\n\n### [1.3.0] - 2024-01-15\n- **Community and Collaboration Tools**:\n  - Launched community forums to foster interaction and support among users.\n  - Established documentation for contributions and community-driven projects.\n  - Initiated a series of webinars and hackathons focused on DuneAI use cases.\n\n### [1.4.0] - 2024-02-28\n- **Testing and Quality Assurance**:\n  - Developed a comprehensive testing suite to ensure the reliability and robustness of the framework.\n  - Engaged the user community for beta testing of new features before general release.\n\n### [1.5.0] - 2024-03-30\n- **Security Enhancements**:\n  - Improved security features including strengthened API key management.\n  - Updated compliance measures to align with industry standards for data protection and security practices.\n\n### [Future Releases]\n- Discussions regarding adaptive learning, broader integration with IoT, and additional testing frameworks are currently in progress. Keep an eye on upcoming releases and community discussions for potential changes.\n\n---\n\nThis changelog serves as a living document, maintaining transparency about project updates and fostering trust within the DuneAI community. If you have suggested changes or bug reports, please share them via the GitHub issues page for consideration in future updates.\n```",
      "Inspiration": "```markdown\n## Inspiration\n\nDuneAI draws inspiration from various fields and concepts that have shaped its development and philosophy. The framework is not just a tool for orchestrating AI workflows; it embodies principles of adaptability, intelligence, and collaboration. Below are some of the key sources of inspiration that influenced the creation and evolution of DuneAI:\n\n### 1. **Cybernetics**\n   - The primary philosophical underpinning of DuneAI comes from the field of cybernetics, which studies the control and communication in animals and machines. This discipline emphasizes feedback loops, adaptive systems, and the self-regulation of behavior. By incorporating these principles, DuneAI allows AI to learn from its outputs and adjust its strategies dynamically.\n\n### 2. **Artificial Intelligence Research**\n   - The advancements in AI research inspired DuneAI's architecture, particularly the focus on creating a framework that seamlessly integrates various AI models and services. By leveraging state-of-the-art algorithms and models, DuneAI aims to provide users with powerful tools to build sophisticated and intelligent workflows.\n\n### 3. **Modularity in Software Design**\n   - The modular design philosophy prevalent in modern software engineering has been a significant influence on DuneAI. By focusing on creating reusable componentsâ€”Dynamics and Promptsâ€”DuneAI allows users to innovate and personalize their workflows while maintaining a clear and organized structure.\n\n### 4. **Open-Source Collaboration**\n   - DuneAI is built on the idea of open-source collaboration, inspired by successful projects in the developer community (such as TensorFlow, Apache Airflow, and Kubernetes). The belief in collective knowledge-sharing and contributing to a shared goal motivates the DuneAI project. By promoting an inclusive development environment, DuneAI aims to empower developers around the world to contribute to and shape its future.\n\n### 5. **User-Centric Design Principles**\n   - The goal of making DuneAI accessible and user-friendly stems from principles of user-centric design. It encourages the creation of tools that are both powerful and easy to understand, allowing a wide range of usersâ€”from beginners to expertsâ€”to effectively leverage AI in their projects. This approach emphasizes the importance of documentation, usability, and community feedback in the development process.\n\n### 6. **Real-World Applications**\n   - DuneAI takes inspiration from real-world applications of AI in various sectors, such as healthcare, finance, and education. Observing how AI can solve complex problems and improve efficiency in these fields has guided the framework's design and functionality, ensuring it meets the practical needs of users.\n\n### 7. **Philosophy of Continuous Improvement**\n   - Building on ideas from iterative development and Agile methodologies, DuneAI embodies a philosophy of continuous improvement. This encourages frequent updates, community engagement, and responsiveness to user feedback, driving the frameworkâ€™s evolution in alignment with usersâ€™ needs and technological advancements.\n\n### Conclusion\n\nThe inspiration behind DuneAI is a blend of interdisciplinary ideas that converge in a commitment to creating a powerful, flexible, and user-friendly framework for AI orchestration. By synthesizing these influences, DuneAI aims to not only provide cutting-edge technology but also foster a supportive community where innovation and collaboration can thrive. The journey of DuneAI is just beginning, and it invites all users and contributors to be part of its story.\n```",
      "Test Cases": "```markdown\n## Test Cases\n\nTesting is a crucial aspect of the software development lifecycle, ensuring that the DuneAI framework operates correctly and efficiently. This section outlines the test cases designed to verify the functionality and performance of the core components of DuneAI. Each test case aims to validate specific behaviors and edge cases to maintain robustness and reliability in production environments.\n\n### 1. **Dynamic Execution Tests**\n\n#### Test Case 1: Basic Dynamic Execution\n- **Objective**: Verify that a basic dynamic can be created and executed successfully.\n- **Input**: A simple prompt asking for a greeting.\n- **Expected Output**: The dynamic should return the expected greeting response without errors.\n\n```typescript\nconst greetingDynamic = DuneAI.createDynamic(\"GreetingDynamic\", {}, [{ name: \"GreetingPrompt\", content: \"What would you like to say?\" }]);\n(async () => {\n    const result = await greetingDynamic.run({});\n    console.assert(result !== undefined, \"Dynamic execution failed: Result should not be undefined.\");\n})();\n```\n\n#### Test Case 2: Multiple Prompt Execution\n- **Objective**: Test if a dynamic can handle multiple prompts and return results for each.\n- **Input**: Two prompts asking about tasks and associated tools.\n- **Expected Output**: The dynamic should return valid responses for both prompts without any errors.\n\n```typescript\nconst taskDynamic = DuneAI.createDynamic(\"TaskDynamic\", {}, [\n    { name: \"TaskPrompt1\", content: \"What is your task?\" },\n    { name: \"TaskPrompt2\", content: \"What tools will you use?\" }\n]);\n(async () => {\n    const results = await taskDynamic.run({});\n    console.assert(results.TaskPrompt1 !== undefined, \"Task prompt execution failed: Result should not be undefined.\");\n    console.assert(results.TaskPrompt2 !== undefined, \"Task prompt execution failed: Result should not be undefined.\");\n})();\n```\n\n### 2. **Error Handling Tests**\n\n#### Test Case 3: Handling Undefined Prompts\n- **Objective**: Verify that the dynamic throws an appropriate error when initialized with undefined prompts.\n- **Input**: An empty array of prompts.\n- **Expected Output**: The system should throw an error indicating that prompts are required.\n\n```typescript\ntry {\n    const errorDynamic = DuneAI.createDynamic(\"ErrorDynamic\", {}, []);\n    await errorDynamic.run({});\n} catch (error) {\n    console.assert(error.message.includes(\"prompts are required\"), \"Error handling failed: Expected error not thrown.\");\n}\n```\n\n### 3. **Throttling Mechanisms**\n\n#### Test Case 4: API Rate Limiting\n- **Objective**: Check if the throttling mechanism limits API calls as expected.\n- **Input**: A script that attempts to make multiple API calls rapidly.\n- **Expected Output**: Only the allowed number of API calls should be made, and others should be queued as per the rate limits set.\n\n```typescript\n(async () => {\n    const startTime = Date.now();\n    for (let i = 0; i < 15; i++) {\n        await someAPICallFunction(); // Replace with actual API call that is throttled\n    }\n    const elapsedTime = Date.now() - startTime;\n    console.assert(elapsedTime >= expectedTotalTime, \"Throttling failed: API calls exceeded rate limits.\");\n})();\n```\n\n### 4. **Configuration Tests**\n\n#### Test Case 5: Environment Variable Management\n- **Objective**: Verify that the application can read and utilize environment variables correctly.\n- **Input**: Set predefined environment variables in `.env`.\n- **Expected Output**: The application should configure itself using the provided environment variables upon initialization.\n\n```typescript\nimport dotenv from 'dotenv';\ndotenv.config();\nconsole.assert(process.env.OPENAI_API_KEY !== undefined, \"Environment variable OPENAI_API_KEY not set properly.\");\n```\n\n### Conclusion\n\nThese test cases serve as a foundational basis for ensuring the functionality, stability, and performance of the DuneAI framework. By executing these tests regularly, developers can detect issues early, verify changes, and ensure that DuneAI continues to meet the demands of its users efficiently. Future enhancements to the testing framework will include more comprehensive coverage and performance benchmarks as the project evolves.\n```"
    },
    "EditDynamic": {
      "Edit": "# DuneAI: The World's First Open Source Cybernetic Orchestration Framework\n\nDuneAI is a groundbreaking artificial intelligence orchestration framework, built on the principles of cybernetics. As the world's first open-source Cybernetic Orchestration Framework, DuneAI brings a new level of intelligence, flexibility, and adaptability to AI workflows. Unlike conventional systems, DuneAI enables AI to analyze its own outputs and adjust future actions, resulting in self-evolving, adaptive systems.\n\n## Core Concepts\n\nWhat sets DuneAI apart is its ability to form cybernetic feedback loops, allowing AI to continuously refine its behavior based on its outputs. While traditional frameworks focus on chaining operations or data retrieval, DuneAI empowers AI to learn from its results and autonomously modify its decision-making processes. This capacity makes DuneAI particularly effective for complex workflows that require ongoing adaptation.\n\n### Components of DuneAI\n\nDuneAI's functionality revolves around two core constructs: **Dynamics** and **Prompts**.\n\n- **Dynamics** are state-aware, reusable components that manage how workflows are executed, adapting based on the AI's evolving state to allow for flexible orchestration.\n\n- **Prompts** are modular commands that interface with AI models. Enhanced with Mustache syntax, Prompts allow dynamic state injection at runtime, ensuring interactions evolve alongside workflow progress. Prompts retrieve outputs and shape workflows across real-time state changes.\n\nThese constructs work together to enable adaptive orchestration, where workflows adjust and refine themselves through feedback mechanisms.\n\n## Installation\n\nTo install DuneAI, follow these steps to set up a basic Node.js environment:\n\n### Prerequisites\n\n1. **Node.js**: Install Node.js (version 14.x or later) from [nodejs.org](https://nodejs.org/).\n2. **npm (Node Package Manager)**: Included with Node.js. Verify its installation using:\n   ```bash\n   npm -v\n   ```\n3. **Git**: Ensure Git is installed for version control. Download it from [git-scm.com](https://git-scm.com/).\n\n### Step-by-Step Installation\n\n1. **Clone the Repository**:\n   ```bash\n   git clone https://github.com/KenanKStipek/DuneAI.git\n   ```\n\n2. **Navigate to the Project Directory**:\n   ```bash\n   cd DuneAI\n   ```\n\n3. **Install Dependencies**:\n   ```bash\n   npm install\n   ```\n\n4. **Setup Environment Variables**: Create a `.env` file in the root directory with your configuration options:\n   ```plaintext\n   OPENAI_API_KEY=your_openai_api_key_here\n   DEFAULT_MODEL=gpt-4o-mini\n   DEFAULT_ADAPTER=openai\n   ```\n\n5. **Run the Application**:\n   ```bash\n   npm start\n   ```\n\n### Additional Notes\n\n- For TypeScript users: install it globally by running:\n  ```bash\n  npm install -g typescript\n  ```\n\n- Check the [Documentation](https://github.com/KenanKStipek/DuneAI/wiki) for detailed instructions on configuring additional features and settings.\n\n## Usage\n\nDuneAI provides a flexible framework for orchestrating AI workflows, facilitating modularity and adaptability through Dynamics and Prompts.\n\n### Basic Workflow\n\n1. **Import DuneAI**:\n   ```typescript\n   import DuneAI from \"duneai\";\n   ```\n\n2. **Create a Prompt**:\n   ```typescript\n   const prompt = {\n       name: \"GreetingPrompt\",\n       content: \"What would you like to say?\",\n       model: \"gpt-4o-mini\",\n   };\n   ```\n\n3. **Create a Dynamic**:\n   ```typescript\n   const greetingDynamic = DuneAI.createDynamic(\"GreetingDynamic\", {}, [prompt]);\n   ```\n\n4. **Run the Dynamic**:\n   ```typescript\n   (async () => {\n       const result = await greetingDynamic.run({});\n       console.log(result);\n   })();\n   ```\n\n### Advanced Configuration\n\nDuneAI allows for advanced configurations, integrating multiple prompts and decision-making logic based on previous results, facilitating more complex workflows.\n\n## Features\n\nDuneAI enhances AI orchestration through various powerful features:\n\n1. **Cybernetic Feedback Loops**: Enabling continuous adaptation based on outputs.\n2. **Dynamic Workflow Management**: State-aware components that adjust workflows flexibly.\n3. **Modular Prompts**: Commands that dynamically adapt based on runtime states.\n4. **Error Handling and Logging**: Built-in mechanisms for graceful error management.\n5. **Flexible Configuration**: Easily configure through environment variables.\n6. **Throttling Mechanism**: Manages API call rates efficiently using Bottleneck.\n7. **Support for Multiple AI Models and Adapters**: Easily switch between AI models.\n8. **Integration with External Services**: Works well with various AI platforms.\n9. **User-friendly API**: Intuitive methods for managing Dynamics and Prompts.\n10. **Comprehensive Documentation**: Detailed resources for quick onboarding.\n\n## Roadmap\n\nThe DuneAI project is continuously evolving. Hereâ€™s a glimpse into our planned features and improvements:\n\n- **Version 1.0**: Initial release with core features and adapter integration.\n- **Version 1.1**: Enhanced user experience with UI improvements and performance optimizations.\n- **Version 1.2**: Support for multi-language prompts and increased adapter availability.\n- **Future Directions**: Focus on AI personalization, IoT integration, and security enhancements.\n\n## FAQ\n\n1. **What is DuneAI?**  \n   DuneAI is an open-source Cybernetic Orchestration Framework for creating adaptive AI workflows.\n\n2. **How do I install DuneAI?**  \n   Follow the instructions in the [Installation](#installation) section.\n\n3. **What are Dynamics and Prompts?**  \n   Dynamics manage workflow execution, while Prompts are modular commands that interface with AI models.\n\n4. **Can I use multiple AI models?**  \n   Yes, DuneAI supports various AI models via its adapter system.\n\n5. **How do I manage environment variables?**  \n   Use a `.env` file in the root directory to define your variables.\n\n## Contributing\n\nContributions to DuneAI are welcome. To contribute:\n\n1. Fork the repository.\n2. Clone your fork.\n3. Create a branch.\n4. Make changes and test them.\n5. Commit your changes.\n6. Push to your fork.\n7. Submit a pull request.\n\nYour feedback and contributions enhance DuneAIâ€™s capabilities and foster a collaborative community. Thank you for your interest in DuneAI! \n\n## License\n\nDuneAI is licensed under the MIT License, allowing free use, modification, and distribution of the software. Please refer to the full license text in the repository.\n\n## Community and Support\n\nConnect with other users and developers through our GitHub Discussions, community forums, or social media channels for announcements and updates. Your engagement helps create a vibrant DuneAI ecosystem."
    }
  },
  "context": {
    "extractedInfo": "\n\n### /Users/kenanstipek/src/DuneAI/src/adapters/gpt4all.ts\n```typescript\nimport * as gpt from \"gpt4all\";\nimport { throttledOperation } from \"../utils/throttling\";\nimport { MODELS } from \"./\";\n\n// Optional interface for completion options\ninterface CompletionOptions {\n  model: string;\n  verbose?: boolean;\n  device?: string;\n}\n\n// Placeholder for model type (could be more specific based on the library)\ntype ModelType = any;\n\n// Load or get the already loaded model\nasync function getModel(\n  modelPath: string,\n  device: string = \"cpu\",\n): Promise<ModelType> {\n  let model: ModelType | null = null;\n  try {\n    model = await gpt.loadModel(modelPath, { device });\n  } catch (error) {\n    console.error(\"Failed to load model:\", error);\n    throw error;\n  }\n  return model;\n}\n\nconst getCompletion = async (content: string, options: CompletionOptions) => {\n  // @ts-ignore\n  const modelPath = options.model;\n  const modelInstance = await getModel(modelPath, options.device || \"cpu\");\n  const chat = await modelInstance.createChatSession();\n  try {\n    const completion = await gpt.createCompletion(chat, content, options);\n    disposeModel(modelInstance, modelPath);\n    return completion.choices[0].message.content;\n  } catch (error) {\n    console.error(\"Error during completion:\", error);\n    disposeModel(modelInstance, modelPath);\n    throw error;\n  }\n};\n\nexport const ask = async (\n  prompt: string | Record<string, any>,\n  options: CompletionOptions,\n): Promise<string> => {\n  return (await throttledOperation(\n    () => getCompletion(prompt as string, options),\n    {\n      id: prompt,\n    },\n  )) as string;\n};\n\nexport const disposeModel = (model: ModelType, name: string): void => {\n  if (model) {\n    model.dispose();\n  }\n};\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/adapters/index.ts\n```typescript\nimport * as gpt4all from \"./gpt4all\";\nimport * as openai from \"./openai\";\nimport * as sdwebui from \"./sdwebui\";\n\nexport const ADAPTERS = {\n  GPT4ALL: gpt4all,\n  OPENAI: openai,\n  SDWEBUI: sdwebui,\n  gpt4all: gpt4all,\n  openai: openai,\n  sdwebui: sdwebui,\n};\n\nexport const MODELS = {\n  GPT_FOUR: { model: \"gpt-4o\", adapter: \"OPENAI\" },\n  GPT_FOUR_BIG: { model: \"gpt-4-32k\", adapter: \"OPENAI\" },\n  GPT_THREE: { model: \"gpt-3.5-turbo\", adapter: \"OPENAI\" },\n  MISTRAL_7B: {\n    model: \"mistral-7b-openorca.gguf2.Q4_0.gguf\",\n    adapter: \"GPT4ALL\",\n  },\n  ORCA_MINI_3B: { model: \"orca-mini-3b-gguf2-q4_0.gguf\", adapter: \"GPT4ALL\" },\n  NOUS_HERMES: {\n    model: \"Nous-Hermes-2-Mistral-7B-DPO.Q4_0.gguf\",\n    adapter: \"GPT4ALL\",\n  },\n  LLAMA3XXX: {\n    model: \"LexiFun-Llama-3-8B-Uncensored-V1_F16.gguf\",\n    adapter: \"GPT4ALL\",\n  },\n  LLAMA3: {\n    model: \"Meta-Llama-3-8B-Instruct.Q4_0.gguf\",\n    adapter: \"GPT4ALL\",\n  },\n  SD: { model: \"sd\", adapter: \"SDWEBUI\" },\n} as const;\n\n// Unified ask method that delegates to the correct adapter based on the modelKey\nexport async function ask(\n  prompt: string | Record<string, any>,\n  adapterName: string,\n  modelName: string,\n  options?: any,\n) {\n  // @ts-ignore\n  const adapter = ADAPTERS[adapterName];\n  // @ts-ignore\n  const model = MODELS[modelName];\n  return openai.ask(prompt, { model, ...options });\n}\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/adapters/openai.ts\n```typescript\nimport OpenAI from \"openai\";\nimport { throttledOperation } from \"../utils/throttling\";\nimport \"dotenv/config\";\n\nexport const openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\nconst getCompletion = async (content: string, options: {}) => {\n  const params = {\n    messages: [{ role: \"user\", content }],\n    model: 'gpt-4o-mini',\n    ...options,\n  };\n  // @ts-ignore\n  const { adapter: _, ...openaiParams } = params;\n  // @ts-ignore\n  const chatCompletion: OpenAI.Chat.ChatCompletion =\n    await openai.chat.completions.create(\n      {...openaiParams, model: 'gpt-4o-mini'} as OpenAI.Chat.ChatCompletionCreateParams,\n    );\n  return chatCompletion.choices[0].message?.content;\n};\n\nexport const ask = async (\n  prompt: string | Record<string, any>,\n  options?: any,\n) => {\n  return (await throttledOperation(\n    () => getCompletion(prompt as string, options),\n    {\n      id: prompt,\n    },\n  )) as string;\n};\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/adapters/sdwebui.ts\n```typescript\nimport SDWebUI from \"node-sd-webui\";\nimport { throttledOperation } from \"../utils/throttling\";\n\nconst sdWebUI = SDWebUI({\n  apiUrl: \"http://127.0.0.1:7860\",\n});\n\nconst generateImage = async (prompt: string, options: any = {}) => {\n  try {\n    // Include the options in the API call\n    const result = await sdWebUI.txt2img({ prompt, ...options });\n    return result; //.imageUrl; // Adjust based on the actual API response\n  } catch (error) {\n    console.error(\"Error during image generation:\", error);\n    throw error;\n  }\n};\n\nexport const ask = async (\n  prompt: string | Record<string, any>,\n  options?: any,\n) => {\n  if (typeof prompt === \"object\") {\n    options = prompt;\n    prompt = options.prompt;\n  }\n  return await throttledOperation(\n    () => generateImage(prompt as string, options),\n    {\n      id: prompt, // Use prompt as the unique identifier for throttling purposes\n    },\n  );\n};\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/index.ts\n```typescript\nimport { importPrompts } from \"./modules/Prompt\";\nimport { createDynamic } from \"./modules/Dynamic\";\nimport { Accumulator, Inverter, Selector } from \"./modules/Cybernetics\";\nimport { TOT, COT } from \"./modules/constants\";\nimport {\n  PromptParamsType,\n  LifecycleHookType,\n  KeyValuePair,\n  NestedObjectType,\n  DynamicOptionsParamType,\n  SelectorOptionsType,\n  SelectorParamsType,\n  SpiceType,\n  MetaType,\n  DynamicState,\n  PromptType,\n  DynamicType,\n  SelectorType\n} from \"./modules/types\";\n\nexport {\n  createDynamic,\n  importPrompts,\n  Selector,\n  Accumulator,\n  Inverter,\n  TOT,\n  COT,\n  PromptParamsType,\n  LifecycleHookType,\n  KeyValuePair,\n  NestedObjectType,\n  DynamicOptionsParamType,\n  SelectorOptionsType,\n  SelectorParamsType,\n  SpiceType,\n  MetaType,\n  DynamicState,\n  PromptType,\n  DynamicType,\n  SelectorType\n};\n\nexport default {\n  createDynamic,\n  importPrompts,\n  Selector,\n  Accumulator,\n  Inverter,\n  TOT,\n  ToT: TOT,\n  COT,\n  CoT: COT,\n};\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/middleware/index.ts\n```typescript\nexport { createPersistMiddleware } from \"./persist\";\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/middleware/logger.ts\n```typescript\ninterface Logger {\n  info(message: string): void;\n  error(message: string): void;\n  warn(message: string): void;\n}\n\n// Define a default logger using console to use if no custom logger is provided\nconst defaultLogger: Logger = {\n  info: (message) => console.log(message),\n  error: (message) => console.error(message),\n  warn: (message) => console.warn(message),\n};\n\nexport default {\n  info(message: string, ...optionalParams: any[]) {\n    console.log(`INFO: ${message}`, ...optionalParams);\n  },\n\n  error(message: string, ...optionalParams: any[]) {\n    console.error(`ERROR: ${message}`, ...optionalParams);\n  },\n\n  debug(message: string, ...optionalParams: any[]) {\n    console.debug(`DEBUG: ${message}`, ...optionalParams);\n  },\n};\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/middleware/persist.ts\n```typescript\nimport fs from \"fs\";\nimport path from \"path\";\n\nconst persistStateToFile = (state: any, filePath: string) => {\n  const absolutePath = path.resolve(process.cwd(), filePath);\n  fs.writeFileSync(absolutePath, JSON.stringify(state, null, 2));\n};\n\nexport const createPersistMiddleware =\n  (filePath: string) => (config: any) => (set: any, get: any, api: any) => {\n    const newSet = (partial: any, replace: boolean) => {\n      const nextState =\n        typeof partial === \"function\" ? partial(get()) : partial;\n      set(nextState, replace);\n      persistStateToFile(get(), filePath);\n    };\n    return config(newSet, get, api);\n  };\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/modules/Cybernetics/Accumulator/index.ts\n```typescript\nimport { PromptType, KeyValuePair, DynamicState } from \"../../types\";\nimport { createPrompt } from \"../../Prompt\";\nimport { createDynamic } from \"../../Dynamic\";\n\nimport { LAMBDA } from \"../../constants\";\n\nconst DEFAULT_DELIMITER = \",\";\n\ninterface OptionsType {\n  state?: KeyValuePair;\n  context?: KeyValuePair;\n  feedback?: string;\n  completion?: string;\n  aggregate?: string | boolean | ((context?: KeyValuePair, state?: KeyValuePair) => string);\n  replicate?: number | ((context?: KeyValuePair, state?: KeyValuePair) => number);\n  distribute?: string | boolean | ((context?: KeyValuePair, state?: KeyValuePair) => string);\n}\n\nconst pickName = (prompt: KeyValuePair | PromptType | string): string | false =>\n  typeof prompt === \"object\" && \"name\" in prompt && typeof prompt.name === \"string\"\n    ? prompt.name\n    : typeof prompt === \"object\"\n      ? Object.entries(prompt)?.[0]?.[0] || false\n      : LAMBDA;\n\nconst pickContent = (prompt: KeyValuePair | PromptType | string): string | false =>\n  typeof prompt === \"object\" && \"content\" in prompt && typeof prompt.content === \"string\"\n    ? prompt.content\n    : typeof prompt === \"object\"\n      ? typeof Object.entries(prompt)?.[0]?.[1] === \"string\" \n        ? Object.entries(prompt)[0][1] as string\n        : false\n      : false;\n\nconst performReplicate = (\n  prompts: (PromptType | KeyValuePair | string)[],\n  replicate: number | ((context?: KeyValuePair, state?: KeyValuePair) => number),\n  context?: KeyValuePair,\n  state?: KeyValuePair,\n): Array<Partial<PromptType>> => {\n  let replicateCount: number = 0;\n\n  if (typeof replicate === \"function\") {\n    replicateCount = replicate(context, state);\n  } else if (typeof replicate === \"number\") {\n    replicateCount = replicate;\n  }\n\n  const result: Array<Partial<PromptType>> = [];\n\n  prompts.forEach((prompt) => {\n    const promptName = pickName(prompt);\n    const promptContent = pickContent(prompt);\n    const promptObject = typeof prompt === \"object\"\n      ? prompt\n      : { [promptName || LAMBDA]: promptContent };\n\n    for (let i = 0; i < replicateCount; i++) {\n      const newKey = `${promptName}_${i}`;\n      result.push({\n        ...promptObject,\n        name: newKey,\n        content: promptContent || '',\n        spice: {\n          iteration: i,\n        }\n      });\n    }\n  });\n\n  return result;\n};\n\n// an array split by a supplied delemeter.\nconst performDistribute = (\n  completion: string,\n  distribute: string | boolean | ((context?: KeyValuePair, state?: KeyValuePair) => string),\n  context?: KeyValuePair,\n  state?: KeyValuePair,\n): Array<string> => {\n  let distributeDelimiter: string = DEFAULT_DELIMITER;\n  if (typeof distribute === \"function\") {\n    distributeDelimiter = distribute(context, state);\n  } else if (typeof distribute === \"string\") {\n    distributeDelimiter = distribute;\n  } else if (distribute === true) {\n    distributeDelimiter = DEFAULT_DELIMITER;\n  }\n  return completion.split(distributeDelimiter).map((item) => item.trim());\n};\n\nconst performAggregate = (\n  completions: string[],\n  aggregate: string | boolean | ((context?: KeyValuePair, state?: KeyValuePair) => string),\n  context?: KeyValuePair,\n  state?: KeyValuePair,\n): string => {\n  let aggregateDelimiter: string = DEFAULT_DELIMITER;\n  if (typeof aggregate === \"function\") {\n    aggregateDelimiter = aggregate(context, state);\n  } else if (typeof aggregate === \"string\") {\n    aggregateDelimiter = aggregate;\n  } else if (aggregate === true) {\n    aggregateDelimiter = DEFAULT_DELIMITER;\n  }\n  return completions.join(aggregateDelimiter);\n};\n\n// Changes string into an array and then back into a sorted list as an array\n// Accumulator('colors: 1) blue, 2) orange, 3) red', { distribute, aggregate })\n// returns: blue, orange, red\nexport const Accumulator = async({\n  basePrompts,\n  options\n}: {\n  basePrompts: (string | KeyValuePair | PromptType)[],\n  options: OptionsType\n}): Promise<string | string[] | PromptType[]> => {\n\n  let prompts: (string | KeyValuePair | PromptType)[] = [...basePrompts];\n  let completion: string | string[] = options.completion || '';\n  let completions: string | string[];\n\n  const { replicate, aggregate, distribute, context, state } =\n    options;\n\n  // valid combos:\n  // replicate: true  | replicate: false | replicate: false\n  // aggregate: true  | aggregate: true  | aggregate: false\n  // distribute: true | distribute: true | distribute: true\n  //\n  // invalid combo (can't do this, replacate creates array and distribute can't consume that)\n  // replicate: true\n  // aggregate: false\n  // distribute: true\n\n  prompts = replicate\n    ? performReplicate(prompts, replicate, context, state) as PromptType[]\n    : prompts;\n\n  completions = distribute\n    ? performDistribute(completion, distribute, context, state)\n    : [completion as string];\n\n  completion = aggregate\n    ? performAggregate(completions, aggregate, context, state)\n    : completions;\n\n  if(completions[0] !== '') {\n    return completions as string[];\n  }\n\n  if(completion !== '' && completion[0] !== '') {\n    return completion as string;\n  }\n\n  return prompts as PromptType[];\n};\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/modules/Cybernetics/Inverter/index.ts\n```typescript\nimport { createDynamic } from '../../Dynamic'\nimport { LAMBDA } from '../index'\nimport { \n  DynamicState\n} from '../../types'\n\nconst defaultCriteria = '\"truthy\" or \"falsey\"'\nconst prompt = (criteria: string, completion: string) => \n  `is this criteria, ${criteria}, false for this completion: ${completion}? \n  respond with t for true or f for false.`\n\nexport const Inverter = async({\n  completion,\n  criteria\n}: { \n  completion: string, \n  criteria?: string\n}): Promise<boolean> => {\n  const dynamic = createDynamic(\n    'InverterCybernetic', {}, \n    [prompt(criteria || defaultCriteria, completion)]\n);\n  const result: DynamicState[\"state\"] = await dynamic.run({});\n  return result?.['InverterCybernetic']?.[LAMBDA]?.includes('t') || false;\n};\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/modules/Cybernetics/Selector/index.ts\n```typescript\nimport { createDynamic } from '../../Dynamic'\nimport { LAMBDA } from '../index'\nimport { \n  SelectorParamsType, \n  DynamicState, \n  SelectorOptionsType \n} from '../../types'\n\nconst defaultCriteria = '\"truthy\" or \"falsey\"'\nconst prompt = (criteria: string, completion: string) => \n  `is this criteria, ${criteria}, true for this completion: ${completion}? \n  respond with t for true or f for false.`\n\nconst greedySelector = async({\n  completions,\n  criteria\n}: { \n  completions: string[], \n  criteria: string\n}): Promise<[number, string] | []> => {\n  let selected: [number, string] | [] = []\n  for (const [index, completion] of completions.entries()) {\n    const dynamic = createDynamic('SelectorCybernetic', {}, [prompt(criteria, completion)]);\n    const result: DynamicState[\"state\"] = await dynamic.run({});\n    if (result?.['SelectorCybernetic']?.[LAMBDA]?.includes('t')) {\n      selected = [index, completion];\n      break;\n    }\n  }\n  return Promise.resolve(selected);\n}\n\nconst generousSelector = async({\n  completions,\n  criteria\n}: { \n  completions: string[], \n  criteria: string\n}): Promise<([number, string] | [])[]> => {\n  const results = await Promise.all(completions.map(async (completion, index) => {\n    const dynamic = createDynamic('SelectorCybernetic', {}, [prompt(criteria, completion)])\n    const result: DynamicState[\"state\"] = await dynamic.run({})\n    if (result?.['SelectorCybernetic']?.[LAMBDA]?.includes('t')) {\n      return [index, completion]\n    }\n    return [];\n  }));\n\n  return results.filter(result => result.length > 0) as [number, string][];\n}\n\nexport const Selector = async({\n  completions,\n  criteria,\n  options\n}: SelectorParamsType): Promise<[number, string] | [] | ([number, string] | [])[]> => {\n  const resolvedCompletions: string[] = typeof completions === 'function' \n    ? completions((options as SelectorOptionsType)?.state as DynamicState[\"state\"]) \n    : completions;\n  const resolvedCriteria: string = typeof criteria === 'function' \n    ? criteria((options as SelectorOptionsType)?.state as DynamicState[\"state\"]) \n    : criteria || defaultCriteria;\n\n  return options?.greedy === true || options?.greedy === undefined\n    ? await greedySelector({ \n      completions: resolvedCompletions, \n      criteria: resolvedCriteria\n    }) \n    : await generousSelector({ \n      completions: resolvedCompletions, \n      criteria: resolvedCriteria\n    })\n};\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/modules/Cybernetics/index.ts\n```typescript\nimport { Accumulator } from \"./Accumulator\";\nimport { Selector } from \"./Selector\";\nimport { Inverter } from \"./Inverter\";\n// import { ThinkingMachine } from \"./ThinkingMachine\";\n\nconst LAMBDA = \"Î»\";\n\n// // Define the base Cybernetic type with shared attributes and methods\n// export interface Cybernetic {\n//   prompt: string;\n//   options: Record<string, unknown>;\n// }\n\n// // Base cybernetic function that could be extended or used for shared functionality\n// export const BaseCybernetic = (\n//   prompt: string,\n//   options: Record<string, unknown>,\n// ): Cybernetic => ({\n//   prompt,\n//   options,\n// });\n\n// Export all cybernetics for use elsewhere in the application\nexport { Selector, Accumulator, Inverter, LAMBDA }; //, Inverter, ThinkingMachine };\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/modules/Dynamic/dependencies.ts\n```typescript\nimport { DynamicType, DynamicState, NestedObjectType } from \"../types\";\nimport { createPrompt } from \"../Prompt\";\nimport { COT } from \"../constants\";\nimport { useStore } from \"../../store\";\n\nexport const run = async (\n  initialState: Record<string, any>,\n  dynamic: DynamicType,\n) => {\n  const { initializeState, setContext } = useStore.getState();\n\n  initializeState(initialState);\n\n  // @ts-ignore\n  setContext(dynamic?.context as NestedObjectType);\n\n  if (dynamic.before) {\n    const beforeResult = \n      (await dynamic.before(useStore.getState().state as DynamicState)) as object;\n    initializeState(beforeResult as NestedObjectType);\n  }\n\n  const strategy =\n    dynamic.kind === COT\n      ? runChainOfThought\n      : runTreeOfThought;\n\n  await strategy(dynamic);\n\n  if (dynamic.after) {\n    const afterResult = (await dynamic.after({\n      ...useStore.getState().state,\n    })) as object;\n    initializeState(afterResult as NestedObjectType);\n  }\n\n  return useStore.getState().state;\n}\n\nconst runChainOfThought = async (dynamic: DynamicType) => {\n  for (const prompt of dynamic.prompts || []) {\n    const { state, context } = useStore.getState();\n    const promptObject = await createPrompt(prompt)\n    const generation = await promptObject.run({\n      ...state,\n      context,\n    } as DynamicState, dynamic.log);\n    useStore.getState().setState(\n      dynamic.name, \n      generation.name, \n      generation.completion\n    );\n  }\n}\n\nconst runTreeOfThought = async (dynamic: DynamicType) => {\n  await Promise.all(dynamic.prompts.map(async (prompt) => {\n    const { state, context } = useStore.getState();\n    const promptObject = await createPrompt(prompt)\n    const generation = await promptObject.run({\n      ...state,\n      context: context as NestedObjectType,\n    } as DynamicState, dynamic.log);\n    useStore.getState().setState(\n      dynamic.name, \n      generation.name, \n      generation.completion\n    );\n  }));\n}\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/modules/Dynamic/index.ts\n```typescript\nimport { run } from \"./dependencies\";\nimport { COT, TOT, LAMBDA } from \"../constants\";\nimport { \n  DynamicType, \n  NestedObjectType, \n  PromptParamsType, \n  DynamicOptionsParamType, \n  DynamicState\n} from \"../types\";\n\nexport const createDynamic = (\n  options: DynamicOptionsParamType | string,\n  context?: NestedObjectType,\n  prompts?: Array<PromptParamsType>,\n  overrides?: Partial<PromptParamsType>\n): DynamicType => {\n  let newDynamic: DynamicType;\n\n  if (typeof options === \"string\") {\n    newDynamic = {\n      name: options as string,\n      kind: COT,\n      context: context as NestedObjectType,\n      prompts: prompts as Array<PromptParamsType>,\n      log: false,\n    } as DynamicType;\n  } else if (typeof options === \"object\") {\n    newDynamic = {\n      name: options.name ?? LAMBDA,\n      kind: options.kind === TOT ? TOT : COT,\n      context: options.context as NestedObjectType,\n      prompts: options.prompts as Array<PromptParamsType>,\n      log: options.log ?? false,\n      before: options.before,\n      after: options.after,\n    } as DynamicType;\n  } else {\n    throw new Error(\"Invalid dynamic params\");\n  }\n\n  return {\n    ...newDynamic,\n    overrides: overrides ?? overrides,\n    run: (initialState: Partial<DynamicState>): Promise<Partial<DynamicState>> => \n      run(initialState, newDynamic),\n  }\n}\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/modules/Prompt/dependencies.ts\n```typescript\nimport path from \"path\";\nimport fs from \"fs\";\nimport Mustache from \"mustache\";\n\nimport { PromptType, DynamicState } from \"../types\";\nimport { LAMBDA } from \"../constants\";\nimport { ask } from \"../../adapters\";\nimport { countTokens } from \"../../utils\";\nimport Logger from \"../../middleware/logger\";\n\nexport const run = async(prompt: PromptType, state: DynamicState, log: boolean) => {\n  let runningPrompt: PromptType = prompt;\n  runningPrompt = prefixSpice(runningPrompt);\n  runningPrompt = interpolateSpice(runningPrompt);\n  runningPrompt = interpolateState(runningPrompt, state);\n\n  if (log) logPrompt(prompt, 'sending', runningPrompt.content as string);\n  const completion = await performCompletion(runningPrompt) || '';\n  if (log) logPrompt(prompt, 'complete', completion);\n\n  return Promise.resolve({\n    ...suffixSpice(runningPrompt, completion),\n    ...runningPrompt,\n    completion,\n  });\n}\n\nconst logPrompt = (prompt: PromptType, status: 'sending' | 'complete', content: string) => {\n  const maxLength = 0;\n  const contentWithoutNewlines = content.replace(/\\n/g, '');\n  const preview = contentWithoutNewlines.length > maxLength ? contentWithoutNewlines.substring(0, maxLength) + '...' : contentWithoutNewlines;\n  const { tokenCount} = countTokens(content, 'gpt-4o-mini');\n  const message = `${prompt.name} - ${status.toUpperCase()}: ${preview} (Total tokens: ${tokenCount.toLocaleString()})`;\n  Logger.info(message);\n}\n\nexport const importPrompts = (\n  dirOrFilePath: string,\n): Record<string, string> => {\n  const absolutePath = path.resolve(process.cwd(), dirOrFilePath);\n\n  if (fs.lstatSync(absolutePath).isDirectory()) {\n    const prompts: Record<string, string> = {};\n    const filePaths = fs\n      .readdirSync(absolutePath)\n      .filter((file) => file.endsWith(\".prompt\"));\n\n    filePaths.forEach((filePath) => {\n      const fileName = path.basename(filePath, path.extname(filePath));\n      prompts[fileName] = importPrompt(path.join(absolutePath, filePath));\n    });\n\n    return prompts;\n  } else {\n    const content = importPrompt(absolutePath);\n    return parsePromptsFromFile(content);\n  }\n};\n\nconst interpolateSpice = (prompt: PromptType): PromptType => {\n  const interpolate = (content: string, params: Record<string, any>): string => {\n    const keys = Object.keys(params);\n    const values = Object.values(params);\n    return new Function(...keys, `return \\`${content}\\`;`)(...values);\n  };\n\n  const content = interpolate(prompt.content, prompt.spice);\n\n  return {\n    ...prompt,\n    content,\n  };\n}\n\nconst prefixSpice = (prompt: PromptType): PromptType => {\n  const startedAt = new Date();\n  const currentTime = new Date();\n  const seed = Math.random();\n  return {\n    ...prompt,\n    spice: {\n      // possible iteration info \n      // is passed with the prompt\n      ...prompt.spice,\n      currentTime,\n      startedAt,\n      seed,\n    },\n  };\n}\n\nconst suffixSpice = (prompt: PromptType, completion: string): PromptType => {\n  const finishedAt = new Date();\n  const duration = \n    (finishedAt.getTime() - \n    (prompt.spice?.startedAt?.getTime() || 0));\n  const { tokenCount: tokensSent } =\n    countTokens(prompt.content, prompt.model as string);\n  const { tokenCount: tokensReceived } =\n    countTokens(completion, prompt.model as string);\n\n  const totalTokens = tokensSent + tokensReceived;\n    \n  return {\n    ...prompt,\n    spice: {\n      ...prompt.spice,\n      finishedAt,\n      duration,\n      modelUsed: prompt.model,\n      adapterUsed: prompt.adapter,\n      tokensSent,\n      tokensReceived,\n      totalTokens,\n    },\n  };\n}\n\nconst interpolateState = (prompt: PromptType, state: DynamicState): PromptType => {\n  const content = Mustache.render(prompt.content as string, {\n    ...state,\n    ...{\n      C: state.context,\n      Context: state.context,\n    },\n  });\n  return {\n    ...prompt,\n    content,\n  };\n}\n\nconst performCompletion = async(prompt: PromptType) => {\n  return await ask(prompt.content, prompt.model, prompt.adapter) as string;\n}\n\nconst importPrompt = (filePath: string): string => {\n  const absolutePath = path.resolve(process.cwd(), filePath);\n  return fs.readFileSync(absolutePath, \"utf8\");\n};\n\nconst parsePromptsFromFile = (\n  content: string,\n): Record<string, string> => {\n  const prompts: Record<string, string> = {};\n  const sections = content.split(/^#\\s*(\\w+)/gm);\n\n  for (let i = 1; i < sections.length; i += 2) {\n    const name = sections[i];\n    const promptContent = sections[i + 1].trim();\n    prompts[name] = promptContent;\n  }\n\n  return prompts;\n};\n\nexport const stringToPrompt = (\n  content: string\n): Partial<PromptType> => {\n  return {\n    name: LAMBDA,\n    content,\n  } as Partial<PromptType>;\n}\n\nexport const keyValuePairToPrompt = (\n  name: string, \n  content: string\n): Partial<PromptType> => {\n  return {\n    name,\n    content,\n  } as Partial<PromptType>;\n}\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/modules/Prompt/index.ts\n```typescript\nimport { PromptType, PromptParamsType, DynamicState } from \"../types\";\nimport { getSettings } from \"../settings\";\nimport { \n  run, \n  importPrompts, \n  stringToPrompt, \n  keyValuePairToPrompt \n} from \"./dependencies\";\n  \nconst createPrompt = async(\n  params: PromptParamsType\n): Promise<PromptType> => {\n  let newPrompt: Partial<PromptType>;\n\n  if (typeof params === 'function') {\n    return createPrompt(await params());\n  } else {\n    if (typeof params === 'string') {\n      newPrompt = stringToPrompt(params as string);\n    } else if (typeof params === 'object' && !params?.name) {\n      const [name, content] = Object.entries(params)[0];\n      newPrompt = keyValuePairToPrompt(name, content);\n    } else if (typeof params === 'object') {\n      newPrompt = params as Partial<PromptType>;\n    } else {\n      throw new Error('Invalid prompt params');\n    }\n  }\n\n  return {\n    ...getSettings(),\n    ...newPrompt,\n    run: (state: DynamicState, log: boolean = false) => run(newPrompt as PromptType, state, log)\n  } as PromptType;\n}\n\nexport { importPrompts, createPrompt };\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/modules/constants.ts\n```typescript\nexport const LAMBDA = 'Î»'\nexport const COT = 'chain of thought'\nexport const TOT = 'tree of thought'\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/modules/settings.ts\n```typescript\nimport dotenv from 'dotenv';\ndotenv.config();\n\nexport const getSettings = () => ({\n  model: process.env.DEFAULT_MODEL || \"gpt-4o-mini\",\n  adapter: process.env.DEFAULT_ADAPTER || \"openai\",\n});\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/modules/types.ts\n```typescript\ntype SimplePrompt = string;\ntype KeyValuePrompt = KeyValuePair;\n\nexport type PromptParamsType = \n  PromptType      | \n  SimplePrompt    | \n  KeyValuePrompt  | \n  (() => PromptType | SimplePrompt | KeyValuePrompt) |\n  (() => Promise<PromptType | SimplePrompt | KeyValuePrompt>);\n\nexport type LifecycleHookType = (state: Partial<DynamicState>) => \n  void          | \n  Promise<void> | \n  Promise<Partial<DynamicState>>;\n\nexport interface KeyValuePair {\n  [key: string]: \n    string | \n    number | \n    boolean;\n}\n\nexport interface NestedObjectType {\n  [key: string]: \n    string  | \n    number  | \n    boolean |\n    NestedObjectType;\n}\n\nexport interface DynamicOptionsParamType {\n  kind: string;\n  prompts: PromptParamsType[];\n  context?: NestedObjectType;\n  overrides?: Partial<PromptParamsType>;\n  name?: string;\n  meta?: MetaType;\n  log?: boolean;\n  before?: LifecycleHookType;\n  after?: LifecycleHookType;\n}\n\nexport type SelectorOptionsType = {\n  greedy?: boolean;\n  state?: DynamicState['state'];\n}\n\nexport type SelectorParamsType = {\n  completions: \n    string[] | \n    ((state: DynamicState['state']) => string[]);\n  criteria?: \n    string |\n    ((state: DynamicState['state']) => string);\n  options?: SelectorOptionsType;\n}\n\nexport interface SpiceType {\n  seed?: number;\n  currentTime?: Date;\n  startedAt?: Date;\n  iteration?: number;\n  finishedAt?: Date;\n  duration?: number;\n  tokensSent?: number;\n  tokensReceived?: number;\n  totalTokens?: number;\n  modelUsed?: string;\n  adapterUsed?: string;\n}\n\nexport interface MetaType {\n  startedAt: Date;\n  completedAt: Date;\n  duration: number;\n  tokensSent: number;\n  tokensReceived: number;\n  totalTokens: number;\n}\n\nexport interface DynamicState {\n  state: Record<string, any>;\n  context: NestedObjectType;\n  setState: (dynamicName: string, promptName: string, value: any) => void;\n  setContext: (dynamicName: string, promptName: string, value: any) => void;\n  initializeState: (initialState: NestedObjectType) => void;\n}\n\nexport interface PromptType {\n  name: string;\n  model: string;\n  adapter: string;\n  content: string;\n  completion?: string;\n  spice: SpiceType;\n  options: KeyValuePair;\n  run: (state: DynamicState, log: boolean) => \n    Promise<PromptType>;\n}\n\nexport interface DynamicType {\n  name: string;\n  kind: string;\n  log: boolean;\n  meta: MetaType;\n  context: NestedObjectType;\n  prompts: PromptParamsType[];\n  overrides?: Partial<PromptParamsType>;\n  before?: LifecycleHookType;\n  after?: LifecycleHookType;\n  exportState: () => DynamicState;\n  run: (state: DynamicState['state']) => \n    Promise<Partial<DynamicState>>;\n}\n\nexport interface SelectorType {\n  (params: SelectorParamsType): Promise<\n    [number, string][] |\n    [number, string]\n  >;\n}\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/scripts/GenerateReadme/index.ts\n```typescript\nimport fs from 'fs';\nimport path from 'path';\nimport { execSync } from 'child_process';\n\nimport { StructureDynamic, SectionDynamic, EditDynamic } from './orchistration';\n\nconst introduction = `\nDuneAI: The World's First Open Source Cybernetic Orchestration Framework\n\nDuneAI is a breakthrough in artificial intelligence orchestration, built on the principles of cybernetics. As the worldâ€™s first open-source Cybernetic Orchestration Framework, DuneAI offers a new level of intelligence, flexibility, and adaptability to AI workflows. Unlike conventional systems, DuneAI enables AI to analyze its own outputs and adjust future actions, resulting in self-evolving, adaptive systems.\n\nWhat makes DuneAI unique is its ability to form cybernetic feedback loopsâ€”allowing AI to continuously refine its behavior based on its outputs. While traditional frameworks focus on chaining operations or retrieving data, DuneAI empowers AI to learn from its results and modify its decision-making process autonomously. This makes DuneAI particularly effective for complex workflows that require ongoing adaptation.\nThe Core of DuneAI\n\nDuneAIâ€™s functionality is built around two core constructs: Dynamics and Prompts.\n\n    Dynamics are reusable, state-aware components that manage how workflows are executed. They adapt based on the AI's evolving state, allowing for flexible orchestration.\n\n    Prompts are modular commands that interface with AI models. Enhanced with Mustache syntax, Prompts allow dynamic state injection at runtime, ensuring interactions evolve as workflows progress. Prompts not only retrieve outputs but also shape the workflow in response to real-time state changes.\n\nThese constructs work together to enable adaptive orchestration, where workflows adjust and refine themselves through cybernetic feedback.\nA New Approach to AI Orchestration\n\nDuneAI offers a fresh approach to AI orchestration, focusing on self-refining workflows that evolve through continuous feedback. This adaptive capability goes beyond what is offered by traditional frameworks, providing more intelligent, autonomous systems for handling dynamic tasks.\n\nDuneAI is licensed under the MIT license and was created by Kenan Stipek with the support of the team at AllusionLabs. This README was written by Kenan Stipek and generated by DuneAI itself, using OpenAIâ€™s GPT-4o-mini model to process DuneAIâ€™s own source code.\n`;\n\n\nconst generateReadme = async () => {\n  const sourceDir = path.resolve(__dirname, '../..');\n  const readmePath = path.join(sourceDir, 'README.md');\n\n  // Function to read the source code files\n  const readSourceFiles = (dir: string): string[] => {\n    let results: string[] = [];\n    const gitignorePath = path.resolve(__dirname, '../../../.gitignore');\n    const gitignorePatterns = fs.readFileSync(gitignorePath, 'utf8')\n      .split('\\n')\n      .filter((line) => line && !line.startsWith('#'))\n      .map((pattern) => new RegExp(pattern.replace(/\\*/g, '.*')));\n\n    const isIgnored = (file: string) => {\n      return gitignorePatterns.some((pattern) => pattern.test(file));\n    };\n\n    const list = fs.readdirSync(dir);\n    list.forEach((file) => {\n      file = path.join(dir, file);\n      if (isIgnored(file)) {\n        return;\n      }\n      const stat = fs.statSync(file);\n      if (stat && stat.isDirectory()) {\n        results = results.concat(readSourceFiles(file));\n      } else if (file.endsWith('.ts') || file.endsWith('.js')) {\n        results.push(file);\n      }\n    });\n    return results;\n  };\n\n  // Function to extract relevant information from the source code\n  const extractInfoFromSource = async (files: string[]): Promise<string> => {\n    let info = '';\n    files.forEach((file) => {\n      const content = fs.readFileSync(file, 'utf8');\n      info += `\\n\\n### ${file}\\n\\`\\`\\`typescript\\n${content}\\n\\`\\`\\`\\n`;\n    });\n    return info;\n  };\n\n  // Read all source files\n  const sourceFiles = readSourceFiles(sourceDir);\n\n  // Extract information from the source files\n  const extractedInfo = await extractInfoFromSource(sourceFiles);\n\n  const structure = await StructureDynamic({ extractedInfo, introduction }).run({});\n  let allSections = '';\n  // @ts-ignore\n  for (const rawCurrentSection of structure.Structure.Structure.split(',')) {\n    const currentSection = rawCurrentSection.trim()\n    const sectionContent = await SectionDynamic({ extractedInfo, structure, currentSection, allSections, introduction }).run({});\n    // @ts-ignore\n    allSections += sectionContent.SectionDynamic[currentSection];\n  }\n\n  const edit = await EditDynamic({ allSections: `${introduction}\\n\\n${allSections}` }).run({});\n  // @ts-ignore\n  const finalCopy = edit.EditDynamic.Edit\n\n\n  // Write the extracted information to the README.md file\n  fs.writeFileSync(readmePath, finalCopy);\n};\n\n// Run the generateReadme function\ngenerateReadme().then(() => {\n  console.log('README.md has been generated successfully.');\n}).catch((error) => {\n  console.error('Error generating README.md:', error);\n});\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/scripts/GenerateReadme/orchistration/index.ts\n```typescript\nimport * as path from \"path\";\nimport { createDynamic, importPrompts, Accumulator, COT, PromptType, PromptParamsType } from \"../../../\";\n\nconst fullPath = path.resolve(__dirname, \"./prompts.prompt\");\nconst { Structure, Section, Edit } = importPrompts(fullPath);\n\nexport const StructureDynamic = (context: any) => createDynamic({\n  name: 'Structure',\n  kind: COT,\n  context,\n  prompts: [{ Structure }]\n});\n\nexport const SectionDynamic = (context: any) => createDynamic({\n  name: 'SectionDynamic',\n  kind: COT,\n  context,\n  prompts: [{ [context.currentSection.trim()]: Section }]\n});\n\nexport const EditDynamic = (context: any) => createDynamic({\n  name: 'EditDynamic',\n  kind: COT,\n  context,\n  prompts: [{ Edit }]\n});\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/scripts/setup.js\n```typescript\n#!/usr/bin/env node\n\nconst { Command } = require(\"commander\");\nconst fs = require(\"fs-extra\");\nconst path = require(\"path\");\nconst { execSync } = require(\"child_process\");\n\n// Function to install dependencies\nconst installDependencies = async (\n  projectDir,\n  adapters,\n  providers,\n  typescript,\n) => {\n  const ora = (await import(\"ora\")).default;\n  const dependencies = [];\n\n  dependencies.push(\"DuneAIOrg/duneai\");\n\n  if (typescript) {\n    dependencies.push(\"typescript\");\n    dependencies.push(\"ts-node\");\n  }\n  if (adapters.includes(\"GPT4ALL\")) {\n    dependencies.push(\"gpt4all\");\n  }\n  if (adapters.includes(\"Vercel AI\")) {\n    dependencies.push(\"ai\");\n  }\n  if (adapters.includes(\"SD\")) {\n    // dependencies.push(\"@ai-sdk/standard-diffusion\");\n  }\n\n  const providerDependencies = {\n    OpenAI: \"@ai-sdk/openai\",\n    AzureOpenAI: \"@ai-sdk/azure\",\n    Anthropic: \"@ai-sdk/anthropic\",\n    AmazonBedrock: \"@ai-sdk/amazon-bedrock\",\n    GoogleGenerativeAI: \"@ai-sdk/google\",\n    GoogleVertex: \"@ai-sdk/google-vertex\",\n    Mistral: \"@ai-sdk/mistral\",\n    Cohere: \"@ai-sdk/cohere\",\n    Groq: \"@ai-sdk/openai\",\n    Perplexity: \"@ai-sdk/openai\",\n    Fireworks: \"@ai-sdk/openai\",\n    LLamaCpp: \"nnance/llamacpp-ai-provider\",\n    Ollama: \"sgomez/ollama-ai-provider\",\n    ChromeAI: \"jeasonstudio/chrome-ai\",\n  };\n\n  providers !== \".\" &&\n    providers.forEach((provider) => {\n      if (providerDependencies[provider]) {\n        dependencies.push(providerDependencies[provider]);\n      }\n    });\n\n  if (dependencies.length > 0) {\n    const spinner = ora(\"Installing dependencies...\").start();\n    try {\n      execSync(`npm install ${dependencies.join(\" \")}`, {\n        cwd: projectDir,\n        stdio: \"inherit\",\n      });\n      spinner.succeed(\"Dependencies installed successfully.\");\n    } catch (error) {\n      spinner.fail(\"Error installing dependencies.\");\n      console.error(chalk.red(error));\n    }\n  }\n};\n\n// Function to convert string to camel case\nconst toCamelCase = (str) => {\n  return str\n    .replace(/(?:^\\w|[A-Z]|\\b\\w|\\s+)/g, (match, index) =>\n      index === 0 ? match.toLowerCase() : match.toUpperCase(),\n    )\n    .replace(/\\s+/g, \"\");\n};\n\n// Function to capitalize the first letter of each word\nconst capitalize = (str) => {\n  return str.replace(/\\b\\w/g, (char) => char.toUpperCase());\n};\n\n// Function to create package.json file\nconst createPackageJson = (projectDir, { typescript, projectName }) => {\n  const packageJsonContent = {\n    name: projectName,\n    version: \"0.1.0\",\n    main: typescript ? \"src/index.ts\" : \"src/index.js\",\n    scripts: {\n      start: typescript ? \"ts-node src/index.ts\" : \"node src/index.js\",\n    },\n    dependencies: {\n      duneai: \"github:KenanKStipek/duneai\",\n    },\n  };\n\n  fs.writeFileSync(\n    path.join(projectDir, \"package.json\"),\n    JSON.stringify(packageJsonContent, null, 2),\n  );\n};\n\n// Function to install selected factories\nconst installFactories = async (factories, projectDir) => {\n  const chalk = (await import(\"chalk\")).default;\n  const tmpDir = path.join(projectDir, \"tmpFactories\");\n\n  // Clone the entire repository\n  const repoUrl = \"https://github.com/DuneAIOrg/Factories.git\";\n  console.log(`Cloning repository from ${repoUrl} to ${tmpDir}`);\n\n  try {\n    execSync(`git clone ${repoUrl} ${tmpDir}`, { stdio: \"inherit\" });\n  } catch (err) {\n    console.error(chalk.red(`Failed to clone repository: ${err.message}`));\n    return;\n  }\n\n  // Copy the selected factories to the project directory\n  factories.forEach((factory) => {\n    const srcFactoryDir = path.join(tmpDir, factory);\n    const destFactoryDir = path.join(projectDir, \"src\", \"factories\", factory);\n\n    if (fs.existsSync(srcFactoryDir)) {\n      fs.ensureDirSync(destFactoryDir);\n      fs.copySync(srcFactoryDir, destFactoryDir);\n      console.log(`Successfully copied factory ${factory}`);\n    } else {\n      console.error(\n        chalk.red(`Factory ${factory} does not exist in the repository`),\n      );\n    }\n  });\n\n  // Remove the temporary cloned repository\n  fs.removeSync(tmpDir);\n  console.log(`Removed temporary directory ${tmpDir}`);\n};\n\n// Dynamically import chalk, ora, inquirer, and chalk-animation\nasync function setup() {\n  const chalk = (await import(\"chalk\")).default;\n  const ora = (await import(\"ora\")).default;\n  const inquirer = (await import(\"inquirer\")).default;\n  const inquirerSearchCheckbox = (await import(\"inquirer-search-checkbox\"))\n    .default;\n  const chalkAnimation = (await import(\"chalk-animation\")).default;\n\n  // Register inquirer-search-checkbox prompt\n  inquirer.registerPrompt(\"search-checkbox\", inquirerSearchCheckbox);\n\n  const program = new Command();\n\n  program\n    .name(\"setup\")\n    .description(\"Setup script for initializing DuneAI projects\")\n    .option(\"-n, --name <projectName>\", \"Project name\")\n    .option(\"-f, --factory true|false\", \"Creating a factory?\", false)\n    .option(\"-o, --output <outputDir>\", \"Output directory\")\n    .option(\"-w, --worm, --vvorm\", \"Include VVORM\", false)\n    .option(\"-a, --adapters <adapters>\", \"Include adapters\", \".\")\n    .option(\"--factories <factories>\", \"Install Factories\", \".\")\n    .option(\"-p, --providers <providers>\", \"Include providers\", \".\")\n    .option(\n      \"-e, --example\",\n      \"Include default example 'Hello World' skeleton\",\n      true,\n    )\n    .option(\"-h, --help\", \"Display help for command\");\n\n  program.on(\"--help\", () => {\n    console.log(\"\");\n    console.log(\"Detailed Help:\");\n    console.log(\"\");\n    console.log(\"Options:\");\n    console.log(\"  -n, --name <projectName>          Project name (required)\");\n    console.log(\n      \"                                    Example: --name myProject\",\n    );\n    console.log(\"\");\n    console.log(\n      \"  -o, --output <outputDir>          Output directory for the project\",\n    );\n    console.log(\n      \"                                    Default: Camel case version of the project name\",\n    );\n    console.log(\n      \"                                    Example: --output ./myProjectDir\",\n    );\n    console.log(\"\");\n    console.log(\"  -w, --worm                Include WORM in the project\");\n    console.log(\"                                    Default: false\");\n    console.log(\"                                    Example: --worm\");\n    console.log(\"\");\n    console.log(\n      \"  -a, --adapters <adapters>         Include specified adapters in the project\",\n    );\n    console.log(\n      \"                                    Example: --adapters GPT4ALL,AI,SD\",\n    );\n    console.log(\"\");\n    console.log(\n      \"  -f, --factories <factories>       Install specified factories in the project\",\n    );\n    console.log(\n      \"                                    Example: --factories Factory1,Factory2\",\n    );\n    console.log(\"\");\n    console.log(\n      \"  -p, --providers <providers>       Include specified providers in the project\",\n    );\n    console.log(\n      \"                                    Example: --providers OpenAI,Anthropic\",\n    );\n    console.log(\"\");\n    console.log(\n      \"  -e, --example                     Include default example 'Hello World' skeleton\",\n    );\n    console.log(\"                                    Default: true\");\n    console.log(\"                                    Example: --example\");\n    console.log(\"\");\n    console.log(\"  -h, --help                        Display help for command\");\n    console.log(\"\");\n    console.log(\"Examples:\");\n    console.log(\"  $ setup --name myProject --output ./myProject --worm\");\n    console.log(\n      \"  $ setup --name myProject --adapters GPT4ALL,AI --factories Factory1,Factory2\",\n    );\n    console.log(\"  $ setup --help\");\n    console.log(\"\");\n    console.log(\n      \"For more information, visit https://github.com/KenanKStipek/DuneAI\",\n    );\n  });\n\n  program.parse(process.argv);\n\n  const options = program.opts();\n  const https = require(\"https\");\n  const availableFactories = await new Promise((resolve, reject) => {\n    https\n      .get(\n        \"https://raw.githubusercontent.com/DuneAIOrg/Factories/main/index.json\",\n        (res) => {\n          let data = \"\";\n          res.on(\"data\", (chunk) => {\n            data += chunk;\n          });\n          res.on(\"end\", () => {\n            resolve(JSON.parse(data).map((factory) => factory.name));\n          });\n        },\n      )\n      .on(\"error\", (err) => {\n        reject(err);\n      });\n  });\n\n  const availableProviders = [\n    \"OpenAI\",\n    \"AzureOpenAI\",\n    \"Anthropic\",\n    \"AmazonBedrock\",\n    \"GoogleGenerativeAI\",\n    \"GoogleVertex\",\n    \"Mistral\",\n    \"Cohere\",\n    \"Groq\",\n    \"Perplexity\",\n    \"Fireworks\",\n    \"LLamaCpp\",\n    \"Ollama\",\n    \"ChromeAI\",\n  ];\n\n  const askQuestions = async () => {\n    const questions = [];\n\n    if (!options.name) {\n      questions.push({\n        type: \"input\",\n        name: \"projectName\",\n        message: \"What is the name of your project?\",\n      });\n    }\n\n    if (!options.factory) {\n      questions.push({\n        type: \"confirm\",\n        name: \"factory\",\n        message: \"Are you creating a Factory?\",\n        default: false,\n      });\n    }\n\n    if (!options.output) {\n      questions.push({\n        type: \"input\",\n        name: \"output\",\n        message: \"What is the output directory?\",\n        default: (answers) =>\n          answers.factory\n            ? capitalize(toCamelCase(answers.projectName || options.name))\n            : toCamelCase(answers.projectName || options.name),\n      });\n    }\n\n    questions.push({\n      type: \"confirm\",\n      name: \"typescript\",\n      message: \"Would you like to use TypeScript?\",\n      default: true,\n    });\n\n    questions.push({\n      type: \"confirm\",\n      name: \"worm\",\n      message:\n        \"Would you like to include and use WORM (Workflow Orchestration and Regenerative Monitor)?\",\n      default: false,\n      when: (answers) => !answers.factory,\n    });\n\n    questions.push({\n      type: \"confirm\",\n      name: \"example\",\n      message:\n        \"Would you like to include the example 'Hello World' orchestration?\",\n      default: false,\n      when: (answers) => !answers.factory,\n    });\n\n    questions.push({\n      type: \"checkbox\",\n      name: \"adapters\",\n      message: \"Select adapters to include:\",\n      choices: [\n        { name: \"GPT4ALL\", checked: true, value: \"GPT4ALL\" },\n        { name: \"Vercel AI\", checked: true, value: \"Vercel AI\" },\n        { name: \"Standard Diffusion\", value: \"Standard Diffusion\" },\n      ],\n      when: (answers) => !answers.factory && options.adapters === \".\",\n    });\n\n    questions.push({\n      type: \"checkbox\",\n      name: \"providers\",\n      message: \"Select providers to include:\",\n      choices: availableProviders.map((provider) => ({\n        name: provider,\n        value: provider,\n        checked: provider === \"OpenAI\" || provider === \"Anthropic\",\n      })),\n      pageSize: 5,\n      when: (answers) => {\n        const selectedAdapters =\n          options.adapters === \".\"\n            ? answers.adapters\n            : options.adapters.split(\",\");\n        return !answers.factory && selectedAdapters.includes(\"Vercel AI\");\n      },\n    });\n\n    questions.push({\n      type: \"search-checkbox\",\n      name: \"factories\",\n      message: \"Select factories to install:\",\n      choices: availableFactories,\n      pageSize: 5,\n      when: (answers) => !answers.factory && options.factories === \".\",\n    });\n\n    const answers = await inquirer.prompt(questions);\n\n    return {\n      ...options,\n      ...answers,\n    };\n  };\n\n  const createProjectStructure = async (\n    projectName,\n    outputDir,\n    adapters,\n    factories,\n    providers,\n    typescript,\n    worm,\n    example,\n    factory,\n  ) => {\n    try {\n      const spinner = ora(\"Creating project structure...\").start();\n\n      try {\n        const projectDir = path.resolve(outputDir);\n        fs.ensureDirSync(projectDir);\n\n        if (!factory && factories && factories.length > 0) {\n          installFactories(factories, projectDir);\n        }\n\n        if (!factory) {\n          createPackageJson(projectDir, {\n            projectName,\n            providers,\n            typescript,\n            worm,\n          });\n\n          const configContent = `Project Name: ${projectName}\\nAdapters: ${adapters}\\nFactories: ${factories}\\nProviders: ${providers}\\nInclude WORM: ${worm}\\nInclude Example: ${example}`;\n          fs.writeFileSync(path.join(projectDir, \"README.md\"), configContent);\n\n          // Create .env file with API key placeholders\n          let envContent = ``;\n          providers !== \".\" &&\n            providers?.forEach((provider) => {\n              envContent += `${provider.toUpperCase().replace(/\\s+/g, \"_\")}_API_KEY=###\\n`;\n            });\n          fs.writeFileSync(path.join(projectDir, \".env\"), envContent);\n        }\n\n        if (!example) {\n          fs.ensureDirSync(path.resolve(outputDir, \"src\"));\n\n          const promptsContent = `# Test\nThis is a test, please respond.\n      `;\n          fs.writeFileSync(\n            path.join(projectDir, \"src\", \"Prompts.prompt\"),\n            promptsContent,\n          );\n\n          const indexContent = typescript\n            ? `// @ts-ignore\nimport DuneAI from \"duneai\";\nconst { Test } = DuneAI.importPrompts(\"src/Prompts.prompt\");\n\n// Define a dynamic\nconst dynamic = DuneAI.createDynamic({\n  name: \"TestDynamic\",\n  prompts: [{ Test }],\n});\n\n(async () => {\n  const result = await dynamic.run();\n  console.log({ result });\n})();\n            `\n            : `\nconst DuneAI = require(\"duneai\");\nconst { Test } = DuneAI.importPrompts(\"src/Prompts.prompt\");\n\n// Define a dynamic\nconst dynamic = DuneAI.createDynamic({\n  name: \"TestDynamic\",\n  prompts: [{ Test }],\n});\n\n(async () => {\n  const result = await dynamic.run();\n  console.log({ result });\n})();\n            `;\n\n          fs.writeFileSync(\n            path.join(projectDir, \"src\", typescript ? \"index.ts\" : \"index.js\"),\n            indexContent,\n          );\n        } else {\n          const exampleDir = path.join(__dirname, \"..\", \"src\", \"skeleton\");\n          fs.copySync(exampleDir, projectDir);\n        }\n\n        // Install dependencies based on selections\n        console.log(chalk.bgGrey(chalk.yellow(\"\\nInstalling Dependencies\")));\n        await installDependencies(projectDir, adapters, providers, typescript);\n\n        const adapterRequirements =\n          adapters.includes(\"GPT4ALL\") &&\n          `If you haven't already, install and configure GPT4ALL. More information here: https://github.com/nomic-ai/gpt4all `;\n\n        const envRequirements =\n          providers !== \".\" &&\n          `Add your API key(s) to the .env file for these providers: ${providers.join(\", \")}`;\n\n        const instructions = `${adapterRequirements}\\n${envRequirements}\\n\\nUse \\`cd ${projectDir} && npm run start\\` to run project`;\n\n        const onlyMessage = `${projectName} has been created successfully.`;\n\n        spinner.succeed(onlyMessage);\n        console.log(chalk.bgGrey(chalk.yellow(instructions)));\n      } catch (error) {\n        spinner.fail(\"Error creating project structure.\");\n        console.error(chalk.red(error));\n      }\n    } catch (error) {\n      spinner.fail(\"Error creating project structure.\");\n      console.error(chalk.red(error));\n    }\n  };\n\n  const runSetup = async () => {\n    const bannerText = `\n      ............................................................\n      â–‘.......â–‘â–‘â–‘..â–‘â–‘â–‘â–‘..â–‘â–‘...â–‘â–‘â–‘..â–‘â–‘........â–‘â–‘â–‘......â–‘â–‘â–‘........â–‘\n      â–’..â–’â–’â–’â–’..â–’â–’..â–’â–’â–’â–’..â–’â–’....â–’â–’..â–’â–’..â–’â–’â–’â–’â–’â–’â–’â–’..â–’â–’â–’â–’..â–’â–’â–’â–’â–’..â–’â–’â–’â–’\n      â–“..â–“â–“â–“â–“..â–“â–“..â–“â–“â–“â–“..â–“â–“..â–“..â–“..â–“â–“......â–“â–“â–“â–“..â–“â–“â–“â–“..â–“â–“â–“â–“â–“..â–“â–“â–“â–“\n      â–ˆ..â–ˆâ–ˆâ–ˆâ–ˆ..â–ˆâ–ˆ..â–ˆâ–ˆâ–ˆâ–ˆ..â–ˆâ–ˆ..â–ˆâ–ˆ....â–ˆâ–ˆ..â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ........â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ..â–ˆâ–ˆâ–ˆâ–ˆ\n      â–ˆ.......â–ˆâ–ˆâ–ˆâ–ˆ......â–ˆâ–ˆâ–ˆ..â–ˆâ–ˆâ–ˆ...â–ˆâ–ˆ........â–ˆâ–ˆ..â–ˆâ–ˆâ–ˆâ–ˆ..â–ˆâ–ˆ........â–ˆ\n      ............................................................\n      `;\n\n    const animation = chalkAnimation.karaoke(bannerText, 9);\n    setTimeout(async () => {\n      animation.stop();\n      console.log(chalk.bgYellow(chalk.black(\"Starting setup...\")));\n      const answers = await askQuestions();\n      createProjectStructure(\n        answers.projectName,\n        answers.output,\n        answers.adapters,\n        answers.factories,\n        answers.providers,\n        answers.typescript,\n        answers.worm,\n        answers.example,\n        answers.factory,\n      );\n    }, 450);\n  };\n\n  runSetup();\n}\n\nsetup();\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/skeleton/config.ts\n```typescript\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/skeleton/src/dynamics/index.ts\n```typescript\nimport * as path from \"path\";\nimport { createDynamic, importPrompts, TOT } from \"../../../\";\n\nconst fullPath = path.resolve(__dirname, \"../prompts/Prompts.prompt\");\nconst { Continent, Languages, HelloWorld, Respond } = importPrompts(fullPath);\n\nconst COUNT = 4;\n\nconst context = { count: COUNT };\n\nconst PickLocale = createDynamic(\"PickLocale\", context, [\n  {\n    name: \"Continent\",\n    content: Continent,\n    model: \"gpt-4o-mini\",\n  },\n  { Languages },\n]);\nconst RespondToAll = createDynamic(\"RespondToAll\", context, [{ Respond }]);\n\nexport const SayHelloWorld = createDynamic({\n  name: \"SayHelloWorld\",\n  kind: TOT,\n  context,\n  prompts: [{ HelloWorld }],\n  before: async (state) => await PickLocale.run(state),\n  after: async (state) => await RespondToAll.run(state),\n});\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/skeleton/src/index.ts\n```typescript\nimport { createDynamic, Accumulator } from \"../..\";\nimport { LAMBDA, TOT } from \"../../modules/constants\";\n\nconst ideaCount = 50;\nconst scale = 100;\n\n(async () => {\n\n  // Come up with a list of poem ideas\n  const prompt = { \n    PoemIdeas: 'Write me a list of {{ context.ideaCount }} poem ideas, only the list, comma separated'\n  };\n  const PoemIdeaDynamic = createDynamic('PoemIdeaDynamic', { ideaCount }, [prompt]);\n  const { PoemIdeaDynamic: { PoemIdeas } } = await PoemIdeaDynamic.run({}) as any;\n\n  // Distribute the list into an array of poem ideas\n  const poemIdeas = await Accumulator({ basePrompts: [], options: { \n    completion: PoemIdeas, \n    distribute: true\n  } }) as string[];\n\n  // Create a prompt for each poem idea and write a poem about it\n  const poemPrompts = poemIdeas.map((idea ) => ({ \n    [idea]: `write a poem about, don't include the title: ${idea}` \n  }));\n  const PoemWriterDynamic = createDynamic({\n    name: 'PoemWriterDynamic', \n    prompts: poemPrompts,\n    kind: TOT\n  });\n  const poems = await PoemWriterDynamic.run({}) as any;\n\n  // Rate the poems\n  const justPoems = Object.values(poems.PoemWriterDynamic)\n  const ratingPrompts = justPoems.map((poem, index) => ({ \n    [index]: `\n      rate this poem on a scale of 1 to {{ context.scale }}, \n      consider the creativity, depth, and emotional impact, \n      only return the rating: ${poem}` \n  } ))\n  const PoemRatingsDynamic = createDynamic({\n    name: 'PoemRatingsDynamic', \n    prompts: ratingPrompts,\n    context: { scale },\n    kind: TOT\n  });\n  const poemRatings = await PoemRatingsDynamic.run({}) as any;\n\n  // Sort the poems by rating and get the short list\n  const sortedPoems = Object.entries(poemRatings.PoemRatingsDynamic)\n    .sort(([, ratingA], [, ratingB]) => parseInt(ratingB as string) - parseInt(ratingA as string))\n    .map(([index]) => justPoems[parseInt(index)]);\n  const bestPoem = sortedPoems[0]\n\n  // name the best poem\n  const namePrompt = `name this poem, return only the name: ${bestPoem}`;\n  const PoemNamerDynamic = createDynamic('PoemNamerDynamic', {}, [namePrompt]);\n  const result = await PoemNamerDynamic.run({}) as any;\n  const name = result.PoemNamerDynamic[LAMBDA];\n\n  console.log(\"My favorite poem that I wrote is:\\n\");\n  console.log(name);\n  console.log(\"\\n\");\n  console.log(bestPoem);\n})();\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/store/index.ts\n```typescript\nimport { createStore } from \"zustand/vanilla\";\nimport { createPersistMiddleware } from \"../middleware\";\nimport type { DynamicState, NestedObjectType } from \"../modules/types\";\n\nexport const useStore = createStore<DynamicState>(\n  createPersistMiddleware(\"state.json\")((set: Function) => ({\n    state: {},\n    context: {},\n    setState: (dynamicName: string, key: string, value: any) =>\n      set((store: { state: Record<string, any> }) => ({\n        state: {\n          ...store.state,\n          [dynamicName]: {\n            ...(store.state[dynamicName] || {}),\n            [key]: value,\n          },\n        },\n      })),\n    setContext: (context: NestedObjectType) =>\n      set(\n        (store: {\n          state: DynamicState[\"state\"];\n          context: DynamicState[\"context\"];\n        }) => ({\n          context: {\n            ...store.context,\n            ...context,\n          },\n        }),\n      ),\n    initializeState: (initialState: NestedObjectType) =>\n      set((store: DynamicState) => ({\n        state: {\n          ...store.state,\n          ...initialState,\n        },\n      })),\n  })),\n);\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/utils/index.ts\n```typescript\nimport tiktoken, { type TiktokenModel } from \"tiktoken\";\n\nexport const wait = (ms: number) => new Promise((r) => setTimeout(r, ms));\n\nexport const retryOperation = (\n  operation: any,\n  delay: number,\n  retries: number,\n) =>\n  new Promise((resolve, reject) => {\n    return operation()\n      .then(resolve)\n      .catch((reason: string) => {\n        if (retries > 0) {\n          return wait(delay)\n            .then(retryOperation.bind(null, operation, delay, retries - 1))\n            .then(resolve)\n            .catch(reject);\n        }\n        return reject(reason);\n      });\n  });\n\nexport const shuffle = (array: string[][]) => {\n  return array\n    .map((value) => ({ value, sort: Math.random() }))\n    .sort((a, b) => a.sort - b.sort)\n    .map(({ value }) => value);\n};\n\nexport const attemptObjectification = (content: string) => {\n  // check if the object can be objectified\n};\n\nexport const objectify = (content: string) => {\n  // check if the content string is a valid json object,\n  // if so, return it as a js object\n};\n\nexport const countTokens = (\n  content: string,\n  model: string,\n): { modelUsed: string; tokenCount: number } => {\n  let enc;\n  let tokenCount;\n  let modelUsed = model;\n  try {\n    enc = tiktoken.encoding_for_model(model as TiktokenModel);\n    tokenCount = enc.encode(content).length;\n  } catch {\n    modelUsed = \"gpt-4o\";\n    enc = tiktoken.encoding_for_model(modelUsed as TiktokenModel);\n    tokenCount = enc.encode(content).length;\n  } finally {\n    enc?.free();\n  }\n  return {\n    modelUsed,\n    tokenCount,\n  };\n};\n\n```\n\n\n### /Users/kenanstipek/src/DuneAI/src/utils/throttling.ts\n```typescript\nimport Bottleneck from \"bottleneck\";\nimport { retryOperation } from \"./\";\n\nexport const DELAY = 500;\nexport const RETRY_COUNT = 3;\nexport const MAX_RPM = 10000;\nexport const MAX_CONCURRENT = MAX_RPM;\n\n// Setup for the bottleneck limiter\nconst limiter = new Bottleneck({\n  minTime: 60000 / MAX_RPM,\n  maxConcurrent: MAX_CONCURRENT,\n});\n\n// Generalized function to perform throttled operations with retries\nexport const throttledOperation = async (\n  operation: () => Promise<any>,\n  options?: any,\n) => {\n  return await limiter.schedule(\n    () => retryOperation(operation, DELAY, RETRY_COUNT),\n    {\n      priority: 1,\n      weight: 1,\n      id: options?.id || \"default_id\",\n    },\n  );\n};\n\n```\n",
    "introduction": "\nDuneAI: The World's First Open Source Cybernetic Orchestration Framework\n\nDuneAI is a breakthrough in artificial intelligence orchestration, built on the principles of cybernetics. As the worldâ€™s first open-source Cybernetic Orchestration Framework, DuneAI offers a new level of intelligence, flexibility, and adaptability to AI workflows. Unlike conventional systems, DuneAI enables AI to analyze its own outputs and adjust future actions, resulting in self-evolving, adaptive systems.\n\nWhat makes DuneAI unique is its ability to form cybernetic feedback loopsâ€”allowing AI to continuously refine its behavior based on its outputs. While traditional frameworks focus on chaining operations or retrieving data, DuneAI empowers AI to learn from its results and modify its decision-making process autonomously. This makes DuneAI particularly effective for complex workflows that require ongoing adaptation.\nThe Core of DuneAI\n\nDuneAIâ€™s functionality is built around two core constructs: Dynamics and Prompts.\n\n    Dynamics are reusable, state-aware components that manage how workflows are executed. They adapt based on the AI's evolving state, allowing for flexible orchestration.\n\n    Prompts are modular commands that interface with AI models. Enhanced with Mustache syntax, Prompts allow dynamic state injection at runtime, ensuring interactions evolve as workflows progress. Prompts not only retrieve outputs but also shape the workflow in response to real-time state changes.\n\nThese constructs work together to enable adaptive orchestration, where workflows adjust and refine themselves through cybernetic feedback.\nA New Approach to AI Orchestration\n\nDuneAI offers a fresh approach to AI orchestration, focusing on self-refining workflows that evolve through continuous feedback. This adaptive capability goes beyond what is offered by traditional frameworks, providing more intelligent, autonomous systems for handling dynamic tasks.\n\nDuneAI is licensed under the MIT license and was created by Kenan Stipek with the support of the team at AllusionLabs. This README was written by Kenan Stipek and generated by DuneAI itself, using OpenAIâ€™s GPT-4o-mini model to process DuneAIâ€™s own source code.\n",
    "structure": {
      "Structure": {
        "Structure": "Installation, Usage, Getting Started, Features, Components, Examples, License, Roadmap, FAQ, Troubleshooting, Future Work, Related Projects, Resources, Contributing, Community, Changelog, Inspiration, Test Cases"
      }
    },
    "currentSection": "Test Cases",
    "allSections": "\nDuneAI: The World's First Open Source Cybernetic Orchestration Framework\n\nDuneAI is a breakthrough in artificial intelligence orchestration, built on the principles of cybernetics. As the worldâ€™s first open-source Cybernetic Orchestration Framework, DuneAI offers a new level of intelligence, flexibility, and adaptability to AI workflows. Unlike conventional systems, DuneAI enables AI to analyze its own outputs and adjust future actions, resulting in self-evolving, adaptive systems.\n\nWhat makes DuneAI unique is its ability to form cybernetic feedback loopsâ€”allowing AI to continuously refine its behavior based on its outputs. While traditional frameworks focus on chaining operations or retrieving data, DuneAI empowers AI to learn from its results and modify its decision-making process autonomously. This makes DuneAI particularly effective for complex workflows that require ongoing adaptation.\nThe Core of DuneAI\n\nDuneAIâ€™s functionality is built around two core constructs: Dynamics and Prompts.\n\n    Dynamics are reusable, state-aware components that manage how workflows are executed. They adapt based on the AI's evolving state, allowing for flexible orchestration.\n\n    Prompts are modular commands that interface with AI models. Enhanced with Mustache syntax, Prompts allow dynamic state injection at runtime, ensuring interactions evolve as workflows progress. Prompts not only retrieve outputs but also shape the workflow in response to real-time state changes.\n\nThese constructs work together to enable adaptive orchestration, where workflows adjust and refine themselves through cybernetic feedback.\nA New Approach to AI Orchestration\n\nDuneAI offers a fresh approach to AI orchestration, focusing on self-refining workflows that evolve through continuous feedback. This adaptive capability goes beyond what is offered by traditional frameworks, providing more intelligent, autonomous systems for handling dynamic tasks.\n\nDuneAI is licensed under the MIT license and was created by Kenan Stipek with the support of the team at AllusionLabs. This README was written by Kenan Stipek and generated by DuneAI itself, using OpenAIâ€™s GPT-4o-mini model to process DuneAIâ€™s own source code.\n\n\n```markdown\n## Installation\n\nTo install DuneAI, you need to set up a basic Node.js environment and install the necessary dependencies. Follow the steps below to get started:\n\n### Prerequisites\n\n1. **Node.js**: Ensure you have Node.js (version 14.x or later) installed on your machine. You can download Node.js from [nodejs.org](https://nodejs.org/).\n\n2. **npm (Node Package Manager)**: npm is included with Node.js. You can check if it's installed by running the following command in your terminal:\n\n   ```bash\n   npm -v\n   ```\n\n3. **Git**: Make sure Git is installed for version control and to clone repositories. Download it from [git-scm.com](https://git-scm.com/).\n\n### Step-by-Step Installation\n\n1. **Clone the Repository**: Open a terminal window and run the following command to clone the DuneAI repository to your local machine:\n\n   ```bash\n   git clone https://github.com/KenanKStipek/DuneAI.git\n   ```\n\n2. **Navigate to the Project Directory**: Change your working directory to the newly cloned repository:\n\n   ```bash\n   cd DuneAI\n   ```\n\n3. **Install Dependencies**: Install the required dependencies by running:\n\n   ```bash\n   npm install\n   ```\n\n   This command will install all the necessary packages, including DuneAI's core libraries and optional adapters.\n\n4. **Setup Environment Variables**: DuneAI relies on various configuration options, including API keys for different providers. Create a `.env` file in the root of the project directory and define your variables, for example:\n\n   ```plaintext\n   OPENAI_API_KEY=your_openai_api_key_here\n   DEFAULT_MODEL=gpt-4o-mini\n   DEFAULT_ADAPTER=openai\n   ```\n\n5. **Run the Application**: After installing the dependencies and setting up your environment, you can start the application with the following command:\n\n   ```bash\n   npm start\n   ```\n\n### Additional Notes\n\n- If you are using TypeScript, you may want to install TypeScript globally by running:\n\n  ```bash\n  npm install -g typescript\n  ```\n\n- Check the [Documentation](https://github.com/KenanKStipek/DuneAI/wiki) for more detailed instructions on configuring additional features and settings.\n  \nWith these steps, you should be ready to begin your journey with DuneAI! If you encounter any issues, please refer to the [Troubleshooting](#troubleshooting) section of this README.\n``````markdown\n## Usage\n\nDuneAI provides a flexible framework for orchestrating artificial intelligence workflows. The main components you will work with are Dynamics and Prompts, which allow the system to be both modular and adaptive. Below is a guide on how to effectively use DuneAI in your projects.\n\n### Core Concepts\n\n1. **Dynamics**: These are state-aware components that manage the execution of workflows. Dynamics can adapt based on the evolving state of the AI, allowing for dynamic orchestration of tasks.\n\n2. **Prompts**: Prompts interface with AI models using modular commands. They can leverage Mustache syntax for dynamic state injection, making it possible to shape workflows as they progress.\n\n### Basic Workflow\n\nHere is a simple example of how to use DuneAI to create a dynamic workflow:\n\n1. **Import DuneAI**: Make sure to import the necessary functions and models when creating your scripts.\n\n   ```typescript\n   import DuneAI from \"duneai\";\n   ```\n\n2. **Create a Prompt**: Define the prompts you will use in your dynamics. For example:\n\n   ```typescript\n   const prompt = {\n       name: \"GreetingPrompt\",\n       content: \"What would you like to say?\",\n       model: \"gpt-4o-mini\",\n   };\n   ```\n\n3. **Create a Dynamic**: Use the prompt within a dynamic framework. Hereâ€™s how you can set this up:\n\n   ```typescript\n   const greetingDynamic = DuneAI.createDynamic(\"GreetingDynamic\", {}, [prompt]);\n   ```\n\n4. **Run the Dynamic**: To execute the dynamic, you can call its `run` method:\n\n   ```typescript\n   (async () => {\n       const result = await greetingDynamic.run({});\n       console.log(result);\n   })();\n   ```\n\n### Advanced Configuration\n\nDuneAI also allows for advanced configurations, including using multiple prompts and incorporating logic for decision-making based on previous results. You can chain dynamics together or parameterize them based on user input or context.\n\n#### Example of Using Multiple Prompts\n\n```typescript\nconst multiPromptDynamic = DuneAI.createDynamic(\"MultiPromptDynamic\", {}, [\n    {\n        name: \"FirstPrompt\",\n        content: \"This is your first task.\",\n    },\n    {\n        name: \"SecondPrompt\",\n        content: \"Now proceed to the next task.\",\n    },\n]);\n\n(async () => {\n    const multiResult = await multiPromptDynamic.run({});\n    console.log(multiResult);\n})();\n```\n\n### Error Handling\n\nMake sure to implement error handling when using asynchronous calls. This ensures that unexpected behavior or failures can be managed gracefully.\n\n```typescript\n(async () => {\n    try {\n        const result = await greetingDynamic.run({});\n        console.log(result);\n    } catch (error) {\n        console.error(\"An error occurred while running the dynamic:\", error);\n    }\n})();\n```\n\n### Conclusion\n\nBy utilizing DuneAI's structure of Dynamics and Prompts, you can build responsive and intelligent AI workflows that adapt to dynamic conditions and user inputs. Explore the various features and APIs available in DuneAI to make the most of this orchestration framework.\n```\n```markdown\n## Getting Started\n\nTo begin your journey with DuneAI, follow these steps to set up and execute your first project. This guide will help you understand the essentials of creating Dynamics and Prompts, and how to run them effectively within the DuneAI framework.\n\n### Step 1: Set Up Your Project\n\nAfter installing DuneAI as outlined in the [Installation](#installation) section, you can set up your project structure. Use the following guidelines to initialize your project effectively.\n\n1. **Project Structure**: Create a directory for your project and navigate into it. Organize your files to separate scripts, prompts, and environments.\n\n   ```bash\n   mkdir my-duneai-project\n   cd my-duneai-project\n   mkdir src prompts\n   ```\n\n2. **Create a Configuration File**: Set up a configuration file to manage your environment variables and initial setup.\n\n   ```plaintext\n   # .env\n   OPENAI_API_KEY=your_openai_api_key_here\n   DEFAULT_MODEL=gpt-4o-mini\n   DEFAULT_ADAPTER=openai\n   ```\n\n### Step 2: Create Your First Prompt\n\nDefine your first prompt to interact with the AI model. You can start with a simple prompt and build on it later.\n\n1. **Define a Prompt**: Create a new file named `prompts/HelloWorld.prompt` and add your prompt content.\n\n   ```plaintext\n   # prompts/HelloWorld.prompt\n   What is a friendly greeting?\n   ```\n\n### Step 3: Build Your Dynamic\n\nThe next step is to construct a dynamic that utilizes the prompt you created.\n\n1. **Create a Dynamic Script**: In your `src` folder, create a script named `index.ts` and write the following code to import DuneAI and use the prompt:\n\n   ```typescript\n   import DuneAI from \"duneai\";\n   import { createDynamic } from \"duneai/modules/Dynamic\";\n   import { importPrompts } from \"duneai/modules/Prompt\";\n   \n   const prompts = importPrompts(\"prompts/HelloWorld.prompt\");\n   const greetingDynamic = createDynamic(\"GreetingDynamic\", {}, [prompts.HelloWorld]);\n\n   (async () => {\n       const result = await greetingDynamic.run({});\n       console.log(result);\n   })();\n   ```\n\n### Step 4: Run Your Dynamic\n\n1. **Execute Your Script**: Use the command line to run your script and see the output from your dynamic.\n\n   ```bash\n   npm start\n   ```\n\n   If you set everything up correctly, you should receive a friendly greeting based on the prompt you defined!\n\n### Tips for Building and Running\n\n- **Experiment with Different Prompts**: Try creating multiple prompts in a single file or across different files and see how they can interoperate within a single dynamic.\n  \n- **Check Logs for Errors**: Utilize the default logger to capture errors and outputs. This will help you debug your scripts easily.\n\n- **Modify Environment Variables**: Adjust the `DEFAULT_MODEL` and `DEFAULT_ADAPTER` in your `.env` file to explore different behaviors of the AI model.\n\n### Understanding the Output\n\nThe output you will receive will depend on the content of your prompts and the model you selected. By iterating on your prompts and dynamics, you can refine the interaction and create more sophisticated workflows.\n\n### Conclusion\n\nWith these steps, you're now set up to create, modify, and run your first Dynamics and Prompts using DuneAI. Continue exploring the framework's features to build more complex and adaptive AI workflows!\n``````markdown\n## Features\n\nDuneAI is designed to streamline and enhance AI orchestration through a variety of powerful features that promote adaptability, modularity, and ease of use. Below are some of the key features that make DuneAI a unique solution for AI workflow management:\n\n### 1. **Cybernetic Feedback Loops**\n   - DuneAI incorporates cybernetic principles that allow it to analyze its outputs and adjust future behaviors. This results in self-evolving systems that continuously adapt to provide more accurate and refined responses over time.\n\n### 2. **Dynamic Workflow Management**\n   - **Dynamics** are reusable, state-aware components that manage the execution of workflows. They adapt based on the current state of the AI, allowing for flexible orchestration of tasks across various contexts.\n\n### 3. **Modular Prompts**\n   - **Prompts** provide an easy way to interact with AI models through modular commands. Enhanced with Mustache syntax, prompts can dynamically adjust based on the runtime state, making them powerful tools for shaping AI interactions.\n\n### 4. **Error Handling and Logging**\n   - DuneAI includes built-in error handling capabilities, allowing developers to manage unexpected behaviors gracefully. The default logger captures essential information about operations, making it easier to debug and monitor workflow executions.\n\n### 5. **Flexible Configuration**\n   - Users can easily configure DuneAI through environment variables, enabling customization of key parameters such as default models and adapters. This allows seamless integration with various AI providers and models based on project needs.\n\n### 6. **Throttling Mechanism**\n   - DuneAI employs a robust throttling mechanism using Bottleneck to manage API call rates and concurrency. This ensures that applications remain efficient and do not exceed usage limits while interacting with external AI services.\n\n### 7. **Support for Multiple AI Models and Adapters**\n   - DuneAI supports various AI models and adapters, including OpenAI, GPT4ALL, and others. This flexibility allows developers to select the most suitable model for their specific tasks without having to modify their core logic significantly.\n\n### 8. **Integration with External Services**\n   - DuneAI is designed to work with external services through its modular architecture, enabling easy integration with different AI platforms and tools, enhancing its versatility across different use cases.\n\n### 9. **User-friendly API**\n   - With an intuitive API for creating and managing Dynamics and Prompts, DuneAI makes it easy for developers to implement complex workflows. The API abstracts underlying complexities, allowing users to focus on building their applications.\n\n### 10. **Comprehensive Documentation**\n   - DuneAI includes extensive documentation, providing tutorials and examples to help new users get started quickly. The clarity and detail of the documentation ensure that both novice and experienced developers can take full advantage of all features.\n\n### Conclusion\n\nDuneAI stands out as a powerful open-source framework for AI orchestration, equipped with features that foster intelligent, self-refining workflows. By leveraging its capabilities, developers can build dynamic systems that adapt to user inputs and continuously improve over time.\n```\n```markdown\n## Components\n\nDuneAI is built with several key components that work together to provide a robust and flexible framework for AI orchestration. Each component plays a critical role in enabling the dynamic interaction and adaptability of workflows. Below are the primary components that make up DuneAI:\n\n### 1. **Dynamics**\n   - **Definition**: Dynamics are state-aware entities responsible for managing and executing workflows within the DuneAI framework. They can adapt their behavior based on the evolving state of the system, allowing for efficient orchestration of processes.\n   - **Usage**: Dynamics facilitate the chaining of tasks, making them reusable across different projects. They contain the logic required to monitor and adjust workflows dynamically, ensuring that the system remains responsive to changing conditions.\n\n### 2. **Prompts**\n   - **Definition**: Prompts are modular commands that interact with AI models. They encapsulate specific tasks or questions, allowing for flexible responses based on the given context.\n   - **Features**: Prompts support Mustache syntax, enabling dynamic state injection and advanced templating capabilities. This allows for more intricate and context-aware interactions with AI models, adapting to real-time inputs and conditions.\n\n### 3. **Adapters**\n   - **Definition**: Adapters serve as intermediaries that connect DuneAI with various AI models and services, such as OpenAI, GPT4ALL, and others.\n   - **Functionality**: By abstracting the underlying differences between API calls and models, adapters allow developers to switch between different AI engines with minimal changes to the core logic of their Dynamics and Prompts.\n\n### 4. **Store**\n   - **Definition**: The Store component manages the application's state and context, facilitating the tracking of data across dynamics.\n   - **Functionality**: By employing a persistent state mechanism through the `createPersistMiddleware`, it allows the preservation of state between executions. This ensures a seamless experience when manipulating state-aware Dynamics.\n\n### 5. **Middleware**\n   - **Definition**: Middleware components in DuneAI provide additional functionalities such as logging, state persistence, and other cross-cutting concerns that enhance the core capabilities of the framework.\n   - **Examples**: The default logger captures essential runtime information, while the persist middleware enables state saving and restoration for dynamic workflows.\n\n### 6. **Utils**\n   - **Definition**: Utility functions encompass a range of helper methods designed to simplify common tasks in DuneAI.\n   - **Functionality**: This includes functions for token counting, operation throttling, and other tasks that streamline the development process, allowing developers to focus on building their components without worrying about the underlying implementation details.\n\n### 7. **Settings**\n   - **Definition**: The settings component provides a centralized configuration mechanism for environment variables and default parameters used throughout the DuneAI framework.\n   - **Usage**: This enables developers to customize key parameters such as default model types and adapter configurations without altering code, leading to easier management and scaling of applications.\n\n### Conclusion\n\nThe modular design of DuneAI's components enhances its adaptability and flexibility, making it suitable for a diverse range of AI orchestration tasks. Each component contributes distinct functionality, allowing developers to create robust, responsive, and self-learning AI workflows tailored to specific needs.\n``````markdown\n## Examples\n\nTo help you get started with DuneAI, we've included several examples that demonstrate how to create and execute Dynamics and Prompts in various scenarios. These examples will showcase the flexibility and adaptability of the framework and provide a basis for your own custom implementations.\n\n### Example 1: Basic Greeting Dynamic\n\nThis example demonstrates how to create a simple greeting dynamic using a prompt that asks for user input.\n\n#### Step 1: Define the Prompt\n\nCreate a new file named `prompts/Greeting.prompt` and add the following content:\n\n```plaintext\nWhat is your name?\n```\n\n#### Step 2: Build the Greeting Dynamic\n\nIn your `src/index.ts` file, import the necessary components and set up your dynamic:\n\n```typescript\nimport DuneAI from \"duneai\";\nimport { createDynamic } from \"duneai/modules/Dynamic\";\nimport { importPrompts } from \"duneai/modules/Prompt\";\n\nconst prompts = importPrompts(\"prompts/Greeting.prompt\");\nconst greetingDynamic = createDynamic(\"GreetingDynamic\", {}, [prompts.Greeting]);\n\n(async () => {\n    const result = await greetingDynamic.run({});\n    console.log(`Hello, ${result}!`);\n})();\n```\n\n#### Step 3: Run the Dynamic\n\nExecute the script with the following command:\n\n```bash\nnpm start\n```\n\n### Example 2: Multi-Prompt Dynamic\n\nThis example showcases how to use multiple prompts in a single dynamic, allowing for a more complex workflow.\n\n#### Step 1: Define Multiple Prompts\n\nCreate a new file named `prompts/TaskPrompts.prompt` and add the following content:\n\n```plaintext\nTask 1: What do you want to accomplish?\nTask 2: What tools will you need?\n```\n\n#### Step 2: Build the Multi-Prompt Dynamic\n\nModify your `src/index.ts` file to include multiple prompts:\n\n```typescript\nimport DuneAI from \"duneai\";\nimport { createDynamic } from \"duneai/modules/Dynamic\";\nimport { importPrompts } from \"duneai/modules/Prompt\";\n\nconst prompts = importPrompts(\"prompts/TaskPrompts.prompt\");\nconst taskDynamic = createDynamic(\"TaskDynamic\", {}, [prompts.Task1, prompts.Task2]);\n\n(async () => {\n    const results = await taskDynamic.run({});\n    console.log(`You want to: ${results.Task1}`);\n    console.log(`You will need: ${results.Task2}`);\n})();\n```\n\n#### Step 3: Run the Dynamic\n\nRun the script again to see the outputs for both tasks:\n\n```bash\nnpm start\n```\n\n### Example 3: Advanced Dynamic with Context\n\nIn this example, you will create a dynamic that uses context to influence the responses based on previous user input.\n\n#### Step 1: Define Contextual Prompt\n\nCreate a new file named `prompts/ContextPrompt.prompt`:\n\n```plaintext\nBased on your previous task, what is the most important thing to focus on?\n```\n\n#### Step 2: Build the Contextual Dynamic\n\nIn the `src/index.ts`, set up a dynamic that utilizes context:\n\n```typescript\nimport DuneAI from \"duneai\";\nimport { createDynamic } from \"duneai/modules/Dynamic\";\nimport { importPrompts } from \"duneai/modules/Prompt\";\n\nconst prompts = importPrompts(\"prompts/ContextPrompt.prompt\");\nconst contextualDynamic = createDynamic(\"ContextualDynamic\", { lastTask: \"Scheduling\" }, [prompts.ContextPrompt]);\n\n(async () => {\n    const result = await contextualDynamic.run({});\n    console.log(`For your task of ${contextualDynamic.context.lastTask}, you should focus on: ${result}`);\n})();\n```\n\n#### Step 3: Run the Dynamic\n\nExecute your script once more to see how the context affects the output:\n\n```bash\nnpm start\n```\n\n### Conclusion\n\nThese examples illustrate the simplicity and power of DuneAI in orchestrating AI workflows. By leveraging Dynamics and Prompts, you can create responsive and adaptive systems tailored to specific tasks and user interactions. Experiment with these examples and modify them to suit your needs, exploring the full capabilities of the DuneAI framework!\n``````markdown\n## License\n\nDuneAI is licensed under the MIT License, which allows for free use, modification, and distribution of the software. The full license text is as follows:\n\n```\nMIT License\n\nCopyright (c) [YEAR] [FULL NAME]\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n1. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n2. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n```\n\n### Additional Information\n\nFor contributions, acknowledgments, or to learn more about this license, please refer to the documentation or visit the [Open Source Initiative](https://opensource.org/licenses/MIT) for more details.\n\nBy using DuneAI, you agree to abide by the terms set forth in this license. If you have any questions regarding the license or usage of DuneAI, please feel free to reach out to the maintainers or consult the community forums.\n``````markdown\n## Roadmap\n\nThe DuneAI project is continuously evolving to enhance functionality, performance, and usability. Below is the current roadmap that outlines our planned features, improvements, and updates for future releases.\n\n### Version 1.0: Initial Stable Release\n- **Completion of Core Features**: Finalization of the Dynamics and Prompts architecture, ensuring robust implementation and comprehensive documentation.\n- **Adapter Integration**: Support for key adapters including OpenAI, GPT4ALL, and SDWebUI, enabling versatility in AI model interaction.\n- **Throttling and Rate Limiting**: Implementation of efficient throttling mechanisms to manage API call rates effectively.\n- **Expanded Documentation**: Comprehensive guides and examples to assist users in getting started and utilizing all features effectively.\n\n### Version 1.1: Enhanced User Experience\n- **User Interface Improvements**: Develop a graphical interface for easier project setup and management, making it more accessible to non-developers.\n- **Advanced Error Handling**: Introduce more granular error reporting and logging capabilities to simplify troubleshooting.\n- **Performance Optimization**: Refactor core functionalities to improve execution speed and reduce resource consumption.\n\n### Version 1.2: Feature Expansions\n- **Multi-Language Support**: Expand DuneAIâ€™s capabilities to support additional programming languages for Prompts and Dynamics, increasing accessibility for a broader audience.\n- **AI Model Customization**: Enable users to customize AI models' behavior through configurable parameters and settings, allowing for more personalized interaction.\n- **Increased Adapter Support**: Integrate additional third-party AI service providers to enrich the framework's adaptability and user options.\n\n### Version 1.3: Community and Collaboration\n- **Open Source Contributions**: Facilitate community contributions by enhancing the developer documentation, setting up a contribution guide, and organizing community events.\n- **Forum and Discussion Platform**: Establish a platform for users to share ideas, troubleshooting tips, and enhancements, fostering a collaborative environment.\n- **Sample Projects and Use Cases**: Develop and publish a suite of sample projects demonstrating diverse use cases for DuneAI, providing inspiration and practical guidance.\n\n### Future Directions\n- **AI Personalization and Learning**: Research and implement features for adaptive learning where the AI can learn user preferences and adjust dynamically.\n- **Integration with IoT and Edge Computing**: Extend DuneAIâ€™s capabilities to work with IoT devices and edge computing applications, opening new avenues for AI orchestration.\n- **Enhanced Security Features**: Prioritize security aspects, including API key management and user data handling, to comply with industry standards.\n\n---\n\nWe invite the community to provide feedback on the roadmap and suggest additional features or improvements you would like to see in future releases. Your input is valuable and plays a crucial role in shaping the future of DuneAI!\n``````markdown\n## FAQ\n\n### 1. What is DuneAI?\n\nDuneAI is an open-source Cybernetic Orchestration Framework that enables users to build adaptive AI workflows. It utilizes principles of cybernetics to help AI analyze its outputs and adjust actions dynamically.\n\n### 2. How do I install DuneAI?\n\nTo install DuneAI, you should follow the [Installation](#installation) section in this README. It includes steps for cloning the repository, installing dependencies, and setting up environment variables.\n\n### 3. What are Dynamics and Prompts in DuneAI?\n\n- **Dynamics** are state-aware components that manage and execute workflows. They adapt based on the system's evolving state, allowing for dynamic orchestration.\n\n- **Prompts** are modular commands that interface with AI models. They can leverage Mustache syntax, enabling dynamic state injection at runtime.\n\n### 4. Can I use DuneAI with multiple AI models?\n\nYes! DuneAI supports various AI models through its adapter system. You can easily switch between different AI services, such as OpenAI and GPT4ALL, without altering the core logic of your Dynamics and Prompts.\n\n### 5. How do I manage environment variables for DuneAI?\n\nYou can manage environment variables using a `.env` file at the root of your project directory. You can define variables like `OPENAI_API_KEY`, `DEFAULT_MODEL`, and `DEFAULT_ADAPTER` within this file to configure your DuneAI setup.\n\n### 6. Are there any built-in logging or error handling features in DuneAI?\n\nYes, DuneAI includes a default logging mechanism. It captures runtime information and errors, allowing you to debug and monitor your workflows easily. Additionally, youâ€™re encouraged to implement your own error handling around asynchronous calls.\n\n### 7. How can I contribute to the DuneAI project?\n\nWe welcome contributions to the DuneAI project! You can read our contribution guidelines in the [Contributing](#contributing) section of this README. Contributions can include code, documentation, or feedback on features and improvements.\n\n### 8. Is there a community or forum for DuneAI users?\n\nYes, there will be a community platform established for users to share ideas, seek help, and discuss features. You can also check our GitHub repository for issues and discussions among the community members.\n\n### 9. Where can I find more documentation or examples?\n\nYou can find comprehensive documentation and additional examples in the project's [Wiki](https://github.com/KenanKStipek/DuneAI/wiki) and the examples section of this README. These resources will help you get started with using DuneAI and explore its features effectively.\n\n### 10. What should I do if I run into an issue?\n\nIf you encounter any issues while using DuneAI, we encourage you to check the [Troubleshooting](#troubleshooting) section of this README. If the issue persists, please report it on the project's GitHub issues page for assistance.\n\n---\n\nFeel free to reach out if you have any other questions not covered in this FAQ!\n``````markdown\n## Troubleshooting\n\nIf you encounter any issues while using DuneAI, this section provides common problems and their solutions to help you resolve them quickly.\n\n### 1. Installation Issues\n\n**Problem**: Unable to install dependencies after cloning the repository.\n\n**Solution**: \n- Ensure that you have the latest version of Node.js and npm installed by running:\n  ```bash\n  node -v\n  npm -v\n  ```\n- Check if you have an internet connection that allows you to reach npm's registry. If the problem persists, try resetting your npm cache by running:\n  ```bash\n  npm cache clean --force\n  ```\n\n### 2. Environment Variables Not Set\n\n**Problem**: The application fails to start because it can't find required environment variables.\n\n**Solution**: \n- Make sure that your `.env` file is located in the root directory of your project and that it is properly formatted. An example:\n  ```\n  OPENAI_API_KEY=your_openai_api_key_here\n  DEFAULT_MODEL=gpt-4o-mini\n  DEFAULT_ADAPTER=openai\n  ```\n- If you're using a different environment management technique, ensure that your variables are being loaded correctly.\n\n### 3. Errors While Running Dynamics\n\n**Problem**: Encountering errors during the execution of Dynamics.\n\n**Solution**: \n- Check the error message logged to your console. It might provide specific details about what went wrong (e.g., missing prompt, invalid input).\n- If you're running asynchronous operations, ensure that you handle errors correctly using `try-catch` blocks.\n\nExample:\n```typescript\n(async () => {\n    try {\n        const result = await dynamic.run({});\n        console.log(result);\n    } catch (error) {\n        console.error(\"Error executing dynamic:\", error);\n    }\n})();\n```\n\n### 4. API Rate Limits Exceeded\n\n**Problem**: Receiving rate limit errors from the AI service provider.\n\n**Solution**: \n- Familiarize yourself with the rate limits imposed by the AI provider you are using. You can typically find this in the provider's documentation.\n- Adjust your throttling parameters in DuneAI to prevent exceeding these limits. You may need to increase the delay or reduce the number of concurrent requests.\n\n### 5. Logging and Debugging Issues\n\n**Problem**: Not receiving any logs or debug information.\n\n**Solution**: \n- Ensure that the logger is being invoked properly in your code. You can add custom logging statements to monitor the execution flow.\n- Review the logging level; make sure the logger is set to capture the desired level of information (e.g., info, error).\n\n### 6. Unexpected Output from Prompts\n\n**Problem**: The output generated by prompts does not match expected results.\n\n**Solution**: \n- Review the prompt content for precision, ensuring that it is clear and unambiguous.\n- Adjust any dynamic parameters or context passed to the prompt when executing the dynamic to fine-tune its responses.\n\n### 7. General Errors\n\n**Problem**: Encountering general errors that don't fit other categories.\n\n**Solution**: \n- Make sure to check the console for detailed error messages which can guide you in troubleshooting.\n- Review the relevant sections of the DuneAI documentation or raise an issue in the GitHub repository if the problem persists.\n\n### 8. Community Support\n\nIf you continue to face challenges or have specific questions not addressed in this troubleshooting section, consider reaching out to the DuneAI community. You can find discussions, report issues, or seek assistance through the project's GitHub page or the upcoming community forum.\n\nRemember, troubleshooting is a natural part of development, and many users may have similar experiences. Your feedback is valuable in improving DuneAI!\n``````markdown\n## Future Work\n\nAs DuneAI continues to evolve, the development team is committed to enhancing its capabilities, user experience, and overall functionality. Below are some key areas of focus for future work on the DuneAI framework:\n\n### 1. **Enhancing AI Learning Capabilities**\n   - **Adaptive Learning**: Implement features that allow DuneAI to learn from user interactions and adapt its prompts and dynamics based on past behavior and preferences. This includes understanding context better and providing more personalized responses.\n   - **Feedback Mechanism**: Introduce a feedback system where users can rate responses, allowing DuneAI to refine its output quality over time based on real user input.\n\n### 2. **Expanded Integration with AI Services**\n   - **Broader Adapter Support**: Integrate with additional AI service providers and models to provide users with a wider range of options. This includes emerging models and experimental services that may enhance flexibility and functionality.\n   - **Cross-Service Coordination**: Develop the ability to seamlessly manage inter-service communication, enabling more complex workflows that leverage multiple AI models simultaneously.\n\n### 3. **User Interface and Experience Improvements**\n   - **GUI Development**: Explore the possibility of creating a graphical user interface (GUI) to simplify project setup, configuration, and management. This will assist users who may not be comfortable with command-line tools.\n   - **Improved Documentation**: Continue to build comprehensive and user-friendly documentation, including tutorials, API references, and advanced guides to help users get the most out of DuneAI.\n\n### 4. **Performance Optimization and Scalability**\n   - **Optimizing Throttling Mechanisms**: Refine the throttling and rate-limiting systems to ensure optimal performance when interacting with external APIs while maintaining compliance with rate limits.\n   - **Scalability Enhancements**: Enhance the framework's ability to handle larger and more complex workflows. Optimize underlying algorithms and memory management to support high-frequency tasks without degradation in performance.\n\n### 5. **Testing and Quality Assurance**\n   - **Comprehensive Testing Suite**: Develop a suite of automated tests to ensure the reliability and quality of the codebase. This will help catch bugs early and guarantee that new features do not break existing functionality.\n   - **User Testing and Feedback Loop**: Engage with the user community to conduct testing and gather feedback on new features before official releases. This participatory approach will allow for the alignment of DuneAIâ€™s development with user needs and expectations.\n\n### 6. **Community Engagement and Growth**\n   - **Fostering a Community Ecosystem**: Encourage the formation of a community around DuneAI that includes forums, discussions, and collaborative projects. This will facilitate knowledge sharing and project enhancement through community contributions.\n   - **Regular Community Events**: Plan webinars, hackathons, and workshops to introduce new users to DuneAI and encourage current users to contribute through code, documentation, and real-world use cases.\n\n### 7. **Security Enhancements**\n   - **Improved Security Features**: Focus on enhancing security features, particularly concerning API key management and data handling. This will ensure that users can confidently manage sensitive information while using DuneAI in their projects.\n   - **Compliance with Industry Standards**: Align the framework's features and functionalities with relevant industry security standards, ensuring that DuneAI is safe for a variety of applications and use cases.\n\n### Conclusion\n\nThe future of DuneAI is bright as we focus on continuous improvement, community engagement, and expansion of its capabilities. We invite feedback, contributions, and collaboration to help shape the direction of DuneAI and make it an even more powerful tool for AI orchestration.\n``````markdown\n## Related Projects\n\nDuneAI is part of a vibrant ecosystem of tools and frameworks that focus on AI orchestration, machine learning, and dynamic workflows. Exploring these related projects can provide additional insights, functionalities, and integration opportunities. Here are some noteworthy projects that complement DuneAI:\n\n### 1. **Airflow**\n   - **Description**: Apache Airflow is an open-source platform to programmatically author, schedule, and monitor workflows. It is designed to manage complex data workflows with ease, making it suitable for big data processing.\n   - **Key Features**: Airflow allows for easy deployment of workflows as code, has a rich user interface for monitoring and tracking, and supports integration with various data sources and systems.\n   - **Link**: [Apache Airflow](https://airflow.apache.org)\n\n### 2. **Luigi**\n   - **Description**: Luigi is a Python package for building complex data pipelines. It handles dependency resolution and visualization, making it simple to manage tasks in a workflow.\n   - **Key Features**: Luigi allows for defining tasks as Python objects, handling execution order automatically, and visualizing task dependencies through a web interface.\n   - **Link**: [Luigi](https://luigi.readthedocs.io)\n\n### 3. **Prefect**\n   - **Description**: Prefect is a modern workflow orchestration tool that focuses on the user experience and observability. It allows users to define, schedule, and monitor data workflows efficiently.\n   - **Key Features**: Prefect provides a seamless way to build tasks, manage state, and streamline error handling. Its hybrid execution model allows for execution on local or cloud environments.\n   - **Link**: [Prefect](https://www.prefect.io)\n\n### 4. **Temporal**\n   - **Description**: Temporal is an open-source framework for writing distributed applications as code. It provides a simple SDK to construct reliable workflows that are resilient to failures.\n   - **Key Features**: Temporal allows developers to build applications that can deal with complex long-running workflows while maintaining state consistency and reliability.\n   - **Link**: [Temporal](https://temporal.io)\n\n### 5. **Haystack**\n   - **Description**: Haystack is an open-source framework for building search systems that utilize large language models for querying. It focuses on providing fast, derived responses to user queries.\n   - **Key Features**: Haystack supports modular pipelines for different query types and integrates directly with popular AI models, enabling straightforward search setups for AI applications.\n   - **Link**: [Haystack](https://haystack.deepset.ai)\n\n### 6. **Ray**\n   - **Description**: Ray is an open-source framework that simplifies the process of building and running scalable applications, particularly for distributed machine learning and reinforcement learning.\n   - **Key Features**: It provides high-level APIs for building distributed applications, making it suitable for large-scale machine learning tasks and reinforcement learning scenarios.\n   - **Link**: [Ray](https://ray.io)\n\n### 7. **Kubeflow**\n   - **Description**: Kubeflow is an open-source platform designed to run and manage machine learning workflows on Kubernetes. It provides a set of tools for simplifying the machine learning lifecycle.\n   - **Key Features**: Kubeflow supports various ML frameworks and integrates with Kubernetes to offer scalability, deployment, and management of machine learning models.\n   - **Link**: [Kubeflow](https://kubeflow.org)\n\n### Conclusion\n\nThese related projects offer complementary functionalities and tools that enhance the overall capabilities of DuneAI. Whether you are looking to manage data workflows, build distributed applications, or integrate AI models seamlessly, exploring these projects can help expand your toolkit and improve your workflow management processes.\n``````markdown\n## Resources\n\nDuneAI is equipped with numerous resources designed to help you understand and leverage its capabilities effectively. Whether you are looking for documentation, tutorials, or community support, the following resources will be invaluable throughout your journey with DuneAI:\n\n### 1. **Official Documentation**\n   - The official documentation provides comprehensive guides, API references, and examples to help you navigate the features of DuneAI. It covers everything from installation to advanced configurations.\n   - **Link**: [DuneAI Documentation](https://github.com/KenanKStipek/DuneAI/wiki)\n\n### 2. **GitHub Repository**\n   - The GitHub repository contains the source code for DuneAI, a bug tracker, and discussions related to the project. You can also access previous releases and submit issues or feature requests directly.\n   - **Link**: [DuneAI GitHub](https://github.com/KenanKStipek/DuneAI)\n\n### 3. **Community Forum**\n   - Join our upcoming community forum where users can ask questions, share experiences, and collaborate on DuneAI-related projects. This platform will foster discussions among users, contributors, and developers.\n   - **Link**: [DuneAI Community Forum](https://forum.example.com) *(Note: Link to be created)*\n\n### 4. **Tutorials and Examples**\n   - Explore practical tutorials and example projects that demonstrate various use cases for DuneAI. These resources will help you grasp how to implement Dynamics and Prompts in different applications.\n   - **Link**: [DuneAI Tutorials and Examples](https://github.com/KenanKStipek/DuneAI/wiki/Tutorials)\n\n### 5. **API Reference Guide**\n   - The API reference provides detailed descriptions of all methods, classes, and properties available within DuneAI. It is a crucial resource for developers looking to understand how to utilize DuneAI programmatically.\n   - **Link**: [DuneAI API Reference](https://github.com/KenanKStipek/DuneAI/wiki/API-Reference)\n\n### 6. **Blog and News Updates**\n   - Stay informed about the latest features, updates, and use cases of DuneAI through our blog. This is where you can find announcements, release notes, and insights from the development team.\n   - **Link**: [DuneAI Blog](https://blog.example.com) *(Note: Link to be created)*\n\n### 7. **Social Media**\n   - Follow us on our social media channels for announcements, project updates, and community engagement events. Join the conversation and connect with other DuneAI users.\n   - **Twitter**: [@DuneAI](https://twitter.com/DuneAI)  \n   - **LinkedIn**: [DuneAI on LinkedIn](https://linkedin.com/company/duneai) *(Note: Links to be created)*\n\n### 8. **Third-Party Tutorials and Articles**\n   - Several community members and enthusiasts may have published tutorials, blog posts, and videos about using DuneAI effectively. These can provide additional insights and innovative use cases beyond the official documentation.\n   - **Search YouTube or Medium** for user-generated content relevant to DuneAI.\n\n### Conclusion\n\nThese resources are designed to enhance your understanding of DuneAI and support your development efforts. Whether you're getting started or looking to deep-dive into advanced features, the DuneAI community and documentation are here to assist you. Happy exploring!\n``````markdown\n## Contributing\n\nContributions to DuneAI are welcome and encourage a collaborative approach to improving the framework. Whether you are a developer, a user, or someone interested in enhancing DuneAI's capabilities, there are multiple ways you can contribute to the project.\n\n### How to Contribute\n\n1. **Fork the Repository**: Start by forking the DuneAI GitHub repository. You can do this by clicking the \"Fork\" button in the top-right corner of the repository page.\n\n2. **Clone Your Fork**: Once you've forked the repository, clone it to your local machine using the following command:\n   ```bash\n   git clone https://github.com/YOUR_USERNAME/DuneAI.git\n   ```\n\n3. **Create a Branch**: Before making any changes, create a new branch for your feature or bug fix:\n   ```bash\n   git checkout -b my-feature\n   ```\n\n4. **Make Changes**: Implement your changes, whether it involves writing new code, fixing bugs, improving documentation, or adding examples. Ensure that your code adheres to the project's coding guidelines and standards.\n\n5. **Test Your Changes**: Run the tests to verify that your changes work as intended and do not break existing functionality. Contributions with adequate testing are generally appreciated more.\n\n6. **Commit Your Changes**: After testing, commit your changes with a descriptive message:\n   ```bash\n   git commit -m \"Add feature or fix description\"\n   ```\n\n7. **Push Your Changes**: Push your changes back to your forked repository:\n   ```bash\n   git push origin my-feature\n   ```\n\n8. **Create a Pull Request**: Navigate to the original DuneAI repository and you should see an option to create a pull request (PR) from your fork. Fill out the PR template, explaining your changes and the reasoning behind them. This helps maintainers understand the context and intention of your submission.\n\n### Review Process\n\nOnce your pull request is submitted, it will be reviewed by the DuneAI maintainers. They may provide feedback or request changes. Be open to discussions and be ready to make iterative improvements based on the review.\n\n### Issues and Feature Requests\n\nIf you encounter any bugs or have suggestions for new features, please raise an issue on the GitHub repository. Clearly describe the problem or the feature you have in mind, providing as much detail as possible to facilitate understanding and discussion.\n\n### Documentation Contributions\n\nImproving the documentation is key to helping others get started with DuneAI. If you notice any areas that can be clarified, expanded, or corrected, feel free to submit pull requests that enhance the documentation. Your contributions in this area are vital for onboarding new users and improving their experience.\n\n### Join the Community\n\nJoin our community discussions and share your ideas or solutions. Engaging with fellow users and contributors helps foster an enriching environment where knowledge and experiences can be exchanged.\n\n### Code of Conduct\n\nWe adhere to a code of conduct that promotes a welcoming, inclusive, and respectful environment for everyone involved in the DuneAI project. Please ensure your interactions reflect these values.\n\n### Conclusion\n\nThank you for considering contributing to DuneAI! Your involvement is invaluable in making DuneAI a better and more powerful tool for AI orchestration. We look forward to your contributions and ideas, and we appreciate your support in helping the project grow.\n``````markdown\n## Community\n\nThe DuneAI community is a vibrant and collaborative group of users, developers, and enthusiasts who are passionate about AI orchestration and the capabilities of the DuneAI framework. Engaging with the community provides numerous benefits, including support, knowledge sharing, and opportunities for collaboration. Here are some ways you can connect and participate in the DuneAI ecosystem:\n\n### Join the Conversation\n\n1. **GitHub Discussions**: Participate in discussions on our GitHub repository. This platform allows users to ask questions, share ideas, and collaborate on improvements to the DuneAI framework. Engaging with others can help you find solutions to specific challenges and discover innovative ways to use DuneAI.\n   - **Link**: [DuneAI GitHub Discussions](https://github.com/KenanKStipek/DuneAI/discussions)\n\n2. **Community Forum**: A dedicated forum for DuneAI users will be established to provide a space for discussions, troubleshooting, and exchanging ideas. This forum will facilitate communication between users and the development team and serve as a hub for community-driven content.\n   - **Link**: [DuneAI Community Forum](https://forum.example.com) *(Note: Link to be created)*\n\n### Connect on Social Media\n\nStay updated and connect with fellow DuneAI users through social media. Follow us for announcements, tips, user stories, and community events.\n- **Twitter**: [@DuneAI](https://twitter.com/DuneAI)\n- **LinkedIn**: [DuneAI on LinkedIn](https://linkedin.com/company/duneai) *(Note: Link to be created)*\n\n### Community Events\n\nJoin us for events such as webinars, hackathons, and meetups where you can learn about DuneAI, showcase your projects, and network with other users. These events are an excellent opportunity to dive deeper into the framework, collaborate with others, and provide your input on future developments.\n\n### Contribute to Projects\n\nEngaging with the DuneAI community also includes contributing to shared projects, tutorials, and open-source contributions. You're encouraged to share your own projects, insights, and enhancements to DuneAI. Working together on collaborative projects can lead to innovation and improved functionalities within the framework.\n\n### Feedback and Suggestions\n\nYour feedback is crucial for the continuous improvement of DuneAI. Whether you have suggestions for features, enhancements, or any issues you've encountered, don't hesitate to voice your thoughts either directly through GitHub issues or in community discussions. Constructive feedback helps shape the future of DuneAI and keeps the community engaged and thriving.\n\n### Conclusion\n\nIt's a thrilling time to be part of the DuneAI community! By engaging with fellow users, sharing your experiences, and collaborating on projects, you contribute to creating a supportive and innovative environment. We look forward to your involvement and canâ€™t wait to see what we can achieve together in our journey with DuneAI!\n``````markdown\n## Changelog\n\nThe changelog provides a brief summary of the updates, improvements, and bug fixes made to DuneAI over time. Keeping track of changes helps users understand the evolution of the framework and adapt to new features or modifications. Below is the detailed log of changes made in each version:\n\n### [Unreleased]\n- **Enhancements**:\n  - Ongoing work on improving AI learning capabilities through adaptive mechanisms.\n\n### [1.0.0] - 2023-10-01\n- **Initial Release**:\n  - Launched the core framework with the implementation of Dynamics and Prompts.\n  - Integrated key adapters including OpenAI and GPT4ALL for diversified AI model access.\n  - Established a basic throttling mechanism to handle API rate limits effectively.\n  - Provided comprehensive documentation covering installation, usage, and contributing guidelines.\n\n### [1.1.0] - 2023-11-01\n- **User Experience Improvements**:\n  - Enhanced user interface elements to streamline project management.\n  - Implemented advanced error handling, providing clearer logging and error messages.\n  - Performance optimizations across core features to improve execution speed.\n\n### [1.2.0] - 2023-12-01\n- **Feature Expansions**:\n  - Introduced support for multi-language prompts, enhancing flexibility for global users.\n  - Enabled further customization options for AI models through dynamic parameters.\n  - Integrated additional AI service providers, expanding the range of accessible models and functionalities.\n\n### [1.3.0] - 2024-01-15\n- **Community and Collaboration Tools**:\n  - Launched community forums to foster interaction and support among users.\n  - Established documentation for contributions and community-driven projects.\n  - Initiated a series of webinars and hackathons focused on DuneAI use cases.\n\n### [1.4.0] - 2024-02-28\n- **Testing and Quality Assurance**:\n  - Developed a comprehensive testing suite to ensure the reliability and robustness of the framework.\n  - Engaged the user community for beta testing of new features before general release.\n\n### [1.5.0] - 2024-03-30\n- **Security Enhancements**:\n  - Improved security features including strengthened API key management.\n  - Updated compliance measures to align with industry standards for data protection and security practices.\n\n### [Future Releases]\n- Discussions regarding adaptive learning, broader integration with IoT, and additional testing frameworks are currently in progress. Keep an eye on upcoming releases and community discussions for potential changes.\n\n---\n\nThis changelog serves as a living document, maintaining transparency about project updates and fostering trust within the DuneAI community. If you have suggested changes or bug reports, please share them via the GitHub issues page for consideration in future updates.\n``````markdown\n## Inspiration\n\nDuneAI draws inspiration from various fields and concepts that have shaped its development and philosophy. The framework is not just a tool for orchestrating AI workflows; it embodies principles of adaptability, intelligence, and collaboration. Below are some of the key sources of inspiration that influenced the creation and evolution of DuneAI:\n\n### 1. **Cybernetics**\n   - The primary philosophical underpinning of DuneAI comes from the field of cybernetics, which studies the control and communication in animals and machines. This discipline emphasizes feedback loops, adaptive systems, and the self-regulation of behavior. By incorporating these principles, DuneAI allows AI to learn from its outputs and adjust its strategies dynamically.\n\n### 2. **Artificial Intelligence Research**\n   - The advancements in AI research inspired DuneAI's architecture, particularly the focus on creating a framework that seamlessly integrates various AI models and services. By leveraging state-of-the-art algorithms and models, DuneAI aims to provide users with powerful tools to build sophisticated and intelligent workflows.\n\n### 3. **Modularity in Software Design**\n   - The modular design philosophy prevalent in modern software engineering has been a significant influence on DuneAI. By focusing on creating reusable componentsâ€”Dynamics and Promptsâ€”DuneAI allows users to innovate and personalize their workflows while maintaining a clear and organized structure.\n\n### 4. **Open-Source Collaboration**\n   - DuneAI is built on the idea of open-source collaboration, inspired by successful projects in the developer community (such as TensorFlow, Apache Airflow, and Kubernetes). The belief in collective knowledge-sharing and contributing to a shared goal motivates the DuneAI project. By promoting an inclusive development environment, DuneAI aims to empower developers around the world to contribute to and shape its future.\n\n### 5. **User-Centric Design Principles**\n   - The goal of making DuneAI accessible and user-friendly stems from principles of user-centric design. It encourages the creation of tools that are both powerful and easy to understand, allowing a wide range of usersâ€”from beginners to expertsâ€”to effectively leverage AI in their projects. This approach emphasizes the importance of documentation, usability, and community feedback in the development process.\n\n### 6. **Real-World Applications**\n   - DuneAI takes inspiration from real-world applications of AI in various sectors, such as healthcare, finance, and education. Observing how AI can solve complex problems and improve efficiency in these fields has guided the framework's design and functionality, ensuring it meets the practical needs of users.\n\n### 7. **Philosophy of Continuous Improvement**\n   - Building on ideas from iterative development and Agile methodologies, DuneAI embodies a philosophy of continuous improvement. This encourages frequent updates, community engagement, and responsiveness to user feedback, driving the frameworkâ€™s evolution in alignment with usersâ€™ needs and technological advancements.\n\n### Conclusion\n\nThe inspiration behind DuneAI is a blend of interdisciplinary ideas that converge in a commitment to creating a powerful, flexible, and user-friendly framework for AI orchestration. By synthesizing these influences, DuneAI aims to not only provide cutting-edge technology but also foster a supportive community where innovation and collaboration can thrive. The journey of DuneAI is just beginning, and it invites all users and contributors to be part of its story.\n``````markdown\n## Test Cases\n\nTesting is a crucial aspect of the software development lifecycle, ensuring that the DuneAI framework operates correctly and efficiently. This section outlines the test cases designed to verify the functionality and performance of the core components of DuneAI. Each test case aims to validate specific behaviors and edge cases to maintain robustness and reliability in production environments.\n\n### 1. **Dynamic Execution Tests**\n\n#### Test Case 1: Basic Dynamic Execution\n- **Objective**: Verify that a basic dynamic can be created and executed successfully.\n- **Input**: A simple prompt asking for a greeting.\n- **Expected Output**: The dynamic should return the expected greeting response without errors.\n\n```typescript\nconst greetingDynamic = DuneAI.createDynamic(\"GreetingDynamic\", {}, [{ name: \"GreetingPrompt\", content: \"What would you like to say?\" }]);\n(async () => {\n    const result = await greetingDynamic.run({});\n    console.assert(result !== undefined, \"Dynamic execution failed: Result should not be undefined.\");\n})();\n```\n\n#### Test Case 2: Multiple Prompt Execution\n- **Objective**: Test if a dynamic can handle multiple prompts and return results for each.\n- **Input**: Two prompts asking about tasks and associated tools.\n- **Expected Output**: The dynamic should return valid responses for both prompts without any errors.\n\n```typescript\nconst taskDynamic = DuneAI.createDynamic(\"TaskDynamic\", {}, [\n    { name: \"TaskPrompt1\", content: \"What is your task?\" },\n    { name: \"TaskPrompt2\", content: \"What tools will you use?\" }\n]);\n(async () => {\n    const results = await taskDynamic.run({});\n    console.assert(results.TaskPrompt1 !== undefined, \"Task prompt execution failed: Result should not be undefined.\");\n    console.assert(results.TaskPrompt2 !== undefined, \"Task prompt execution failed: Result should not be undefined.\");\n})();\n```\n\n### 2. **Error Handling Tests**\n\n#### Test Case 3: Handling Undefined Prompts\n- **Objective**: Verify that the dynamic throws an appropriate error when initialized with undefined prompts.\n- **Input**: An empty array of prompts.\n- **Expected Output**: The system should throw an error indicating that prompts are required.\n\n```typescript\ntry {\n    const errorDynamic = DuneAI.createDynamic(\"ErrorDynamic\", {}, []);\n    await errorDynamic.run({});\n} catch (error) {\n    console.assert(error.message.includes(\"prompts are required\"), \"Error handling failed: Expected error not thrown.\");\n}\n```\n\n### 3. **Throttling Mechanisms**\n\n#### Test Case 4: API Rate Limiting\n- **Objective**: Check if the throttling mechanism limits API calls as expected.\n- **Input**: A script that attempts to make multiple API calls rapidly.\n- **Expected Output**: Only the allowed number of API calls should be made, and others should be queued as per the rate limits set.\n\n```typescript\n(async () => {\n    const startTime = Date.now();\n    for (let i = 0; i < 15; i++) {\n        await someAPICallFunction(); // Replace with actual API call that is throttled\n    }\n    const elapsedTime = Date.now() - startTime;\n    console.assert(elapsedTime >= expectedTotalTime, \"Throttling failed: API calls exceeded rate limits.\");\n})();\n```\n\n### 4. **Configuration Tests**\n\n#### Test Case 5: Environment Variable Management\n- **Objective**: Verify that the application can read and utilize environment variables correctly.\n- **Input**: Set predefined environment variables in `.env`.\n- **Expected Output**: The application should configure itself using the provided environment variables upon initialization.\n\n```typescript\nimport dotenv from 'dotenv';\ndotenv.config();\nconsole.assert(process.env.OPENAI_API_KEY !== undefined, \"Environment variable OPENAI_API_KEY not set properly.\");\n```\n\n### Conclusion\n\nThese test cases serve as a foundational basis for ensuring the functionality, stability, and performance of the DuneAI framework. By executing these tests regularly, developers can detect issues early, verify changes, and ensure that DuneAI continues to meet the demands of its users efficiently. Future enhancements to the testing framework will include more comprehensive coverage and performance benchmarks as the project evolves.\n```"
  }
}