import fs from 'fs';
import path from 'path';

// @ts-ignore
import { createDynamic, importPrompts, COT } from "duneai";


const fullPath = path.resolve(__dirname, "./prompts.prompt");
const { Structure, Section, Edit } = importPrompts(fullPath);

export const StructureDynamic = (context: any) => createDynamic({
  name: 'Structure',
  kind: COT,
  context,
  prompts: [{ Structure }]
});

export const SectionDynamic = (context: any) => createDynamic({
  name: 'SectionDynamic',
  kind: COT,
  context,
  prompts: [{ [context.currentSection.trim()]: Section }]
});

export const EditDynamic = (context: any) => createDynamic({
  name: 'EditDynamic',
  kind: COT,
  context,
  prompts: [{ Edit }]
});

const introduction = `
DuneAI: The World's First Open Source Cybernetic Orchestration Framework

DuneAI is a breakthrough in artificial intelligence orchestration, built on the principles of cybernetics. As the world’s first open-source Cybernetic Orchestration Framework, DuneAI offers a new level of intelligence, flexibility, and adaptability to AI workflows. Unlike conventional systems, DuneAI enables AI to analyze its own outputs and adjust future actions, resulting in self-evolving, adaptive systems.

What makes DuneAI unique is its ability to form cybernetic feedback loops—allowing AI to continuously refine its behavior based on its outputs. While traditional frameworks focus on chaining operations or retrieving data, DuneAI empowers AI to learn from its results and modify its decision-making process autonomously. This makes DuneAI particularly effective for complex workflows that require ongoing adaptation.
The Core of DuneAI

DuneAI’s functionality is built around two core constructs: Dynamics and Prompts.

    Dynamics are reusable, state-aware components that manage how workflows are executed. They adapt based on the AI's evolving state, allowing for flexible orchestration.

    Prompts are modular commands that interface with AI models. Enhanced with Mustache syntax, Prompts allow dynamic state injection at runtime, ensuring interactions evolve as workflows progress. Prompts not only retrieve outputs but also shape the workflow in response to real-time state changes.

These constructs work together to enable adaptive orchestration, where workflows adjust and refine themselves through cybernetic feedback.
A New Approach to AI Orchestration

DuneAI offers a fresh approach to AI orchestration, focusing on self-refining workflows that evolve through continuous feedback. This adaptive capability goes beyond what is offered by traditional frameworks, providing more intelligent, autonomous systems for handling dynamic tasks.

DuneAI is licensed under the MIT license and was created by Kenan Stipek with the support of the team at AllusionLabs. This README was written by Kenan Stipek and generated by DuneAI itself, using OpenAI’s GPT-4o-mini model to process DuneAI’s own source code.
`;


const generateReadme = async () => {
  const sourceDir = path.resolve(__dirname, '../..');
  const readmePath = path.join(sourceDir, 'README.md');

  // Function to read the source code files
  const readSourceFiles = (dir: string): string[] => {
    let results: string[] = [];
    const gitignorePath = path.resolve(__dirname, '../../../.gitignore');
    const gitignorePatterns = fs.readFileSync(gitignorePath, 'utf8')
      .split('\n')
      .filter((line) => line && !line.startsWith('#'))
      .map((pattern) => new RegExp(pattern.replace(/\*/g, '.*')));

    const isIgnored = (file: string) => {
      return gitignorePatterns.some((pattern) => pattern.test(file));
    };

    const list = fs.readdirSync(dir);
    list.forEach((file) => {
      file = path.join(dir, file);
      if (isIgnored(file)) {
        return;
      }
      const stat = fs.statSync(file);
      if (stat && stat.isDirectory()) {
        results = results.concat(readSourceFiles(file));
      } else if (file.endsWith('.ts') || file.endsWith('.js')) {
        results.push(file);
      }
    });
    return results;
  };

  // Function to extract relevant information from the source code
  const extractInfoFromSource = async (files: string[]): Promise<string> => {
    let info = '';
    files.forEach((file) => {
      const content = fs.readFileSync(file, 'utf8');
      info += `\n\n### ${file}\n\`\`\`typescript\n${content}\n\`\`\`\n`;
    });
    return info;
  };

  // Read all source files
  const sourceFiles = readSourceFiles(sourceDir);

  // Extract information from the source files
  const extractedInfo = await extractInfoFromSource(sourceFiles);

  const structure = await StructureDynamic({ extractedInfo, introduction }).run({});
  let allSections = '';
  // @ts-ignore
  for (const rawCurrentSection of structure.Structure.Structure.split(',')) {
    const currentSection = rawCurrentSection.trim()
    const sectionContent = await SectionDynamic({ extractedInfo, structure, currentSection, allSections, introduction }).run({});
    // @ts-ignore
    allSections += sectionContent.SectionDynamic[currentSection];
  }

  const edit = await EditDynamic({ allSections: `${introduction}\n\n${allSections}` }).run({});
  // @ts-ignore
  const finalCopy = edit.EditDynamic.Edit

  // Write the extracted information to the README.md file
  fs.writeFileSync(readmePath, finalCopy);
};

// Run the generateReadme function
generateReadme().then(() => {
  console.log('README.md has been generated successfully.');
}).catch((error) => {
  console.error('Error generating README.md:', error);
});
